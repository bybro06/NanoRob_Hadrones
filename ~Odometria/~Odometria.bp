lv_velocidad_1 = 0
lv_x_1 = 0
lv_y_1 = 0
lv_theta_1 = 0
gv_centro = 0
gv_xtime = 0
gv_ytime = 0
gv_thetatime = 0
gv_centro = 0
gv_xtime = 0
gv_ytime = 0
gv_thetatime = 0
Thread.Run = f_odometry_0
lv_velocidad_1 = 40
lv_x_1 = - 100
lv_y_1 = 300
lv_theta_1 = 90
f_toxy_4 ()
Program.Delay ( 30000 )
Sub f_odometry_0
gv_alpha_l [ 0 ] = 0
gv_alpha_r [ 0 ] = 0
gv_oldb = 0
gv_oldc = 0
gv_xt [ 0 ] = 0
gv_yt [ 0 ] = 0
gv_thetat [ 0 ] = 0
gv_i = 0
While "True"
gv_dw = 84.5
gv_diameter = 56
gv_alpha_l [ gv_i ] = Math.GetRadians ( MotorB.GetTacho () )
gv_alpha_r [ gv_i ] = Math.GetRadians ( MotorC.GetTacho () )
gv_d_l = ( gv_alpha_l [ gv_i ] - gv_alpha_l [ gv_i - 1 ] ) * gv_diameter / 2
gv_d_r = ( gv_alpha_r [ gv_i ] - gv_alpha_r [ gv_i - 1 ] ) * gv_diameter / 2
gv_d = ( gv_d_l + gv_d_r ) / 2
gv_delta_theta = ( gv_d_r - gv_d_l ) / ( 2 * gv_dw )
gv_xt [ gv_i + 1 ] = ( gv_d * Math.Sin ( gv_thetat [ gv_i ] + gv_delta_theta / 2 ) + gv_xt [ gv_i ] ) * - 1
gv_yt [ gv_i + 1 ] = ( gv_d * Math.Cos ( gv_thetat [ gv_i ] + gv_delta_theta / 2 ) + gv_yt [ gv_i ] ) * - 1
gv_thetat [ gv_i + 1 ] = gv_thetat [ gv_i ] + gv_delta_theta
gv_xtime = gv_xt [ gv_i ]
gv_ytime = gv_yt [ gv_i ]
gv_thetatime = gv_thetat [ gv_i ]
gv_i = gv_i + 1
LCD.StopUpdate ()
LCD.Clear ()
LCD.Write ( 5 , 5 , "xt: " + gv_xt [ gv_i ] )
LCD.Write ( 5 , 15 , "yt: " + gv_yt [ gv_i ] )
LCD.Write ( 5 , 25 , "thetat: " + math.getdegrees ( gv_thetat [ gv_i ] ) )
LCD.Write ( 5 , 35 , "centro: " + gv_centro )
LCD.Update ()
Program.Delay ( 10 )
EndWhile
EndSub
Sub f_toxy_4
lv_i_1 = "B"
lv_d_1 = "C"
lv_g1_1 = 110 / 36
lv_signo_1 = - 1
lv_diff_x_1 = lv_x_1 - gv_xtime
lv_diff_y_1 = lv_y_1 - gv_ytime
lv_angulo_giro_inicial_1 = Math.getDegrees ( Math.ArcTan ( ( lv_x_1 - gv_xtime ) / ( lv_y_1 - gv_ytime ) ) )
If lv_angulo_giro_inicial_1 > 0 Then
lv_v1_1 = lv_velocidad_1
lv_v2_1 = lv_velocidad_1 * - 1
Else
lv_v1_1 = lv_velocidad_1 * - 1
lv_v2_1 = lv_velocidad_1
EndIf
lv_vmin_1 = Math.Min ( Math.Abs ( lv_v1_1 ) , Math.Abs ( lv_v2_1 ) )
lv_vmax_1 = Math.Max ( Math.Abs ( lv_v1_1 ) , Math.Abs ( lv_v2_1 ) )
gv_centro = ( - 8.5 * ( lv_vmin_1 / lv_vmax_1 ) * lv_signo_1 - 8.5 ) / ( ( lv_vmin_1 / lv_vmax_1 ) * lv_signo_1 - 1 )
lv_encodr_1 = lv_angulo_giro_inicial_1 * lv_g1_1 * ( - 2 / ( lv_signo_1 * lv_vmin_1 / lv_vmax_1 - 1 ) )
Motor.MoveSync ( lv_i_1 + lv_d_1 , - lv_v1_1 / 3 , - lv_v2_1 / 3 , lv_encodr_1 , "True" )
lv_distancia_1 = Math.SquareRoot ( lv_diff_x_1 * lv_diff_x_1 + lv_diff_y_1 * lv_diff_y_1 )
lv_enc_1 = lv_distancia_1 * 360 / Math.Pi / gv_diameter
Motor.Move ( "BC" , - lv_velocidad_1 , lv_enc_1 , "True" )
lv_angulo_giro_final_1 = lv_theta_1 - Math.GetDegrees ( gv_thetatime )
If lv_angulo_giro_final_1 > 0 Then
lv_v1_1 = lv_velocidad_1
lv_v2_1 = lv_velocidad_1 * - 1
Else
lv_v1_1 = lv_velocidad_1 * - 1
lv_v2_1 = lv_velocidad_1
EndIf
lv_vmin_1 = Math.Min ( Math.Abs ( lv_v1_1 ) , Math.Abs ( lv_v2_1 ) )
lv_vmax_1 = Math.Max ( Math.Abs ( lv_v1_1 ) , Math.Abs ( lv_v2_1 ) )
gv_centro = ( - 8.5 * ( lv_vmin_1 / lv_vmax_1 ) * lv_signo_1 - 8.5 ) / ( ( lv_vmin_1 / lv_vmax_1 ) * lv_signo_1 - 1 )
lv_encodr_1 = lv_angulo_giro_final_1 * lv_g1_1 * ( - 2 / ( lv_signo_1 * lv_vmin_1 / lv_vmax_1 - 1 ) )
Motor.MoveSync ( lv_i_1 + lv_d_1 , - lv_v1_1 / 2 , - lv_v2_1 / 2 , lv_encodr_1 , "True" )
EndSub
