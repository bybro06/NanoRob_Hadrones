lv_degrees_per_second_a_7 = 0
lv_degrees_per_second_d_7 = 0
lv_degrees_a_7 = 0
lv_degrees_d_7 = 0
lv_degrees_per_second_9 = 0
lv_velocidad_1 = 0
lv_x_1 = 0
lv_y_1 = 0
lv_theta_1 = 0
lv_degrees_per_second_6 = 0
lv_degrees_6 = 0
lv_degrees_per_second_4 = 0
lv_degrees_4 = 0
lv_degrees_per_second_8 = 0
gv_centro = 0
gv_xtime = 0
gv_ytime = 0
gv_thetatime = 0
gv_xtcorrect = 0
gv_ytcorrect = 0
gv_thetatcorrect = 0
gv_sentido_d = 0
gv_angulo = 0
gv_angle_a = 0
gv_angle_d = 0
gv_centro = 0
gv_xtime = 0
gv_ytime = 0
gv_thetatime = 0
gv_xtcorrect = 0
gv_ytcorrect = 0
gv_thetatcorrect = 0
gv_sentido_d = 1
gv_angulo = 0
f_startarm_0 ()
Thread.Run = f_pidcontrol_ad_0
Thread.Run = f_odometry_0
Thread.Run = f_display_0
f_main_0 ()
Program.Delay ( 20000 )
Sub f_startarm_0
lv_degrees_per_second_a_7 = 200
lv_degrees_per_second_d_7 = 200
lv_degrees_a_7 = - 200
lv_degrees_d_7 = 200
f_bmovead_4 ()
Program.Delay ( 1000 )
Motor.ResetCount ( "A" )
Motor.ResetCount ( "D" )
gv_angle_a = 0
gv_angle_d = 0
Time.Reset1 ()
While Time.Get1 () < 500
gv_angle_d = gv_angle_d + 1
Program.Delay ( 5 )
EndWhile
If Math.Abs ( Motor.GetCount ( "D" ) ) < 60 Then
lv_degrees_per_second_9 = 90
f_bmoved0_1 ()
gv_sentido_d = 1
Else
lv_degrees_per_second_9 = 90
f_bmoved0_1 ()
gv_sentido_d = - 1
EndIf
Program.Delay ( 100 )
EndSub
Sub f_odometry_0
gv_alpha_l [ 0 ] = 0
gv_alpha_r [ 0 ] = 0
gv_oldb = 0
gv_oldc = 0
gv_xt [ 0 ] = 0
gv_yt [ 0 ] = 0
gv_thetat [ 0 ] = 0
gv_i = 0
While "True"
gv_dw = 84.5
gv_diameter = 56
gv_alpha_l [ gv_i ] = Math.GetRadians ( MotorB.GetTacho () ) * - 1
gv_alpha_r [ gv_i ] = Math.GetRadians ( MotorC.GetTacho () ) * - 1
gv_d_l = ( gv_alpha_l [ gv_i ] - gv_alpha_l [ gv_i - 1 ] ) * gv_diameter / 2
gv_d_r = ( gv_alpha_r [ gv_i ] - gv_alpha_r [ gv_i - 1 ] ) * gv_diameter / 2
gv_d = ( gv_d_l + gv_d_r ) / 2
gv_delta_theta = ( gv_d_l - gv_d_r ) / ( 2 * gv_dw )
If gv_xtcorrect <> 0 Then
gv_xt [ gv_i + 1 ] = gv_xtcorrect
gv_xtcorrect = 0
Else
gv_xt [ gv_i + 1 ] = ( gv_d * Math.Sin ( gv_thetat [ gv_i ] + gv_delta_theta / 2 ) + gv_xt [ gv_i ] )
EndIf
If gv_ytcorrect <> 0 Then
gv_yt [ gv_i + 1 ] = gv_ytcorrect
gv_ytcorrect = 0
Else
gv_yt [ gv_i + 1 ] = ( gv_d * Math.Cos ( gv_thetat [ gv_i ] + gv_delta_theta / 2 ) + gv_yt [ gv_i ] )
EndIf
If gv_thetatcorrect <> 0 Then
gv_thetat [ gv_i + 1 ] = gv_thetatcorrect
gv_thetatcorrect = 0
Else
gv_thetat [ gv_i + 1 ] = gv_thetat [ gv_i ] + gv_delta_theta
EndIf
gv_xtime = gv_xt [ gv_i + 1 ]
gv_ytime = gv_yt [ gv_i + 1 ]
gv_thetatime = gv_thetat [ gv_i + 1 ]
gv_i = gv_i + 1
Program.Delay ( 10 )
EndWhile
EndSub
Sub f_pidcontrol_ad_0
gv_kp_a = 0.5
gv_ki_a = 0.0001
gv_kd_a = 0.1
gv_kp_d = 0.5
gv_ki_d = 0.0001
gv_kd_d = 0.1
gv_error_a = 0
gv_error_d = 0
gv_errsum_a = 0
gv_errsum_d = 0
gv_olderror_a = 0
gv_olderror_d = 0
gv_u_a = 0
gv_u_d = 0
gv_angle_a = 0
gv_angle_d = 0
While "True"
gv_error_a = gv_angle_a - MotorA.GetTacho ()
gv_errsum_a = gv_errsum_a + gv_error_a
gv_u_a = ( gv_error_a * gv_kp_a ) + ( gv_errsum_a * gv_ki_a / 1 ) + ( ( gv_error_a - gv_olderror_a ) * gv_kd_a )
MotorA.StartSpeed ( gv_u_a )
gv_error_d = gv_angle_d - MotorD.GetTacho ()
gv_errsum_d = gv_errsum_d + gv_error_d
gv_u_d = ( gv_error_d * gv_kp_d ) + ( gv_errsum_d * gv_ki_d / 1 ) + ( ( gv_error_d - gv_olderror_d ) * gv_kd_d ) * gv_sentido_d
MotorD.StartSpeed ( gv_u_d )
EndWhile
EndSub
Sub f_display_0
While "True"
LCD.StopUpdate ()
LCD.Clear ()
LCD.Write ( 5 , 5 , "xt: " + Math.Round ( gv_xt [ gv_i ] * 100 ) / 100 )
LCD.Write ( 5 , 15 , "yt: " + Math.Round ( gv_yt [ gv_i ] * 100 ) / 100 )
LCD.Write ( 5 , 25 , "thetat: " + math.getdegrees ( gv_thetat [ gv_i ] ) )
LCD.Write ( 5 , 35 , "angulo: " + gv_angulo )
LCD.Write ( 5 , 45 , "centro: " + gv_centro )
LCD.Write ( 5 , 65 , "Angulo de A:  " + MotorA.GetTacho () )
LCD.Write ( 5 , 75 , "Obj de A:  " + gv_angle_a )
LCD.Write ( 5 , 85 , "Angulo de D:  " + MotorD.GetTacho () )
LCD.Write ( 5 , 95 , "Obj de D:  " + gv_angle_d )
LCD.Update ()
Program.Delay ( 100 )
EndWhile
EndSub
Sub f_main_0
lv_velocidad_1 = 50
lv_x_1 = - 300
lv_y_1 = 500
lv_theta_1 = 90
f_toxy_basic_4 ()
lv_velocidad_1 = 50
lv_x_1 = 0
lv_y_1 = 0
lv_theta_1 = 0
f_toxy_basic_4 ()
lv_velocidad_1 = 30
lv_x_1 = 0
lv_y_1 = 0
lv_theta_1 = 0
f_toxy_basic_4 ()
EndSub
Sub f_toxy_basic_4
lv_i_1 = "B"
lv_d_1 = "C"
lv_g1_1 = 110 / 36
lv_signo_1 = - 1
lv_diff_x_1 = lv_x_1 - gv_xtime
lv_diff_y_1 = lv_y_1 - gv_ytime
lv_diff_theta_1 = lv_theta_1 - gv_thetatime
lv_angulo_giro_inicial_1 = Math.getDegrees ( Math.ArcTan ( ( lv_x_1 - gv_xtime ) / ( lv_y_1 - gv_ytime ) ) )
gv_angulo = lv_angulo_giro_inicial_1
If lv_diff_x_1 < 0 Then
lv_angulo_giro_inicial_1 = 0 - gv_thetatime - lv_angulo_giro_inicial_1
EndIf
If lv_angulo_giro_inicial_1 > 0 Then
lv_v1_1 = lv_velocidad_1
lv_v2_1 = lv_velocidad_1 * - 1
Else
lv_v1_1 = lv_velocidad_1 * - 1
lv_v2_1 = lv_velocidad_1
EndIf
lv_vmin_1 = Math.Min ( Math.Abs ( lv_v1_1 ) , Math.Abs ( lv_v2_1 ) )
lv_vmax_1 = Math.Max ( Math.Abs ( lv_v1_1 ) , Math.Abs ( lv_v2_1 ) )
gv_centro = ( - 8.5 * ( lv_vmin_1 / lv_vmax_1 ) * lv_signo_1 - 8.5 ) / ( ( lv_vmin_1 / lv_vmax_1 ) * lv_signo_1 - 1 )
lv_encodr_1 = lv_angulo_giro_inicial_1 * lv_g1_1 * ( - 2 / ( lv_signo_1 * lv_vmin_1 / lv_vmax_1 - 1 ) )
Motor.MoveSync ( lv_i_1 + lv_d_1 , - lv_v1_1 / 2 , - lv_v2_1 / 2 , lv_encodr_1 , "True" )
Program.Delay ( 10000 )
lv_distancia_1 = Math.SquareRoot ( lv_diff_x_1 * lv_diff_x_1 + lv_diff_y_1 * lv_diff_y_1 )
lv_enc_1 = lv_distancia_1 * 360 / Math.Pi / gv_diameter
Motor.Move ( "BC" , - lv_velocidad_1 , lv_enc_1 , "True" )
Program.Delay ( 100 )
lv_angulo_giro_final_1 = lv_theta_1 - Math.GetDegrees ( gv_thetatime )
If lv_angulo_giro_final_1 > 0 Then
lv_v1_1 = lv_velocidad_1
lv_v2_1 = lv_velocidad_1 * - 1
Else
lv_v1_1 = lv_velocidad_1 * - 1
lv_v2_1 = lv_velocidad_1
EndIf
lv_vmin_1 = Math.Min ( Math.Abs ( lv_v1_1 ) , Math.Abs ( lv_v2_1 ) )
lv_vmax_1 = Math.Max ( Math.Abs ( lv_v1_1 ) , Math.Abs ( lv_v2_1 ) )
gv_centro = ( - 8.5 * ( lv_vmin_1 / lv_vmax_1 ) * lv_signo_1 - 8.5 ) / ( ( lv_vmin_1 / lv_vmax_1 ) * lv_signo_1 - 1 )
lv_encodr_1 = Math.Abs ( lv_angulo_giro_final_1 * lv_g1_1 * ( - 2 / ( lv_signo_1 * lv_vmin_1 / lv_vmax_1 - 1 ) ) )
Motor.MoveSync ( lv_i_1 + lv_d_1 , - lv_v1_1 / 2 , - lv_v2_1 / 2 , lv_encodr_1 , "True" )
gv_xtcorrect = lv_x_1
gv_ytcorrect = lv_y_1
gv_thetatcorrect = math.getradians ( lv_theta_1 )
Program.Delay ( 100 )
EndSub
Sub f_bmovea_2
lv_rotation_4 = lv_degrees_4 - gv_angle_a
lv_sign_4 = Math.Abs ( lv_rotation_4 ) / lv_rotation_4
lv_progress_4 = 0
lv_degrees_per_interval_4 = lv_degrees_per_second_4 * lv_sign_4 / 50
While Math.Abs ( lv_rotation_4 - lv_progress_4 ) > 5
gv_angle_a = gv_angle_a + lv_degrees_per_interval_4
lv_progress_4 = lv_progress_4 + lv_degrees_per_interval_4
Program.Delay ( 1 )
EndWhile
gv_angle_a = lv_degrees_4
EndSub
Sub f_bmoved_2
lv_rotation_6 = lv_degrees_6 - gv_angle_d
lv_sign_6 = Math.Abs ( lv_rotation_6 ) / lv_rotation_6
lv_progress_6 = 0
lv_degrees_per_interval_6 = lv_degrees_per_second_6 * lv_sign_6 / 50
While Math.Abs ( lv_rotation_6 - lv_progress_6 ) > 5
gv_angle_d = gv_angle_d + lv_degrees_per_interval_6
lv_progress_6 = lv_progress_6 + lv_degrees_per_interval_6
Program.Delay ( 1 )
EndWhile
gv_angle_d = lv_degrees_6
EndSub
Sub f_bmovead_4
While gv_angle_a <> lv_degrees_a_7 Or gv_angle_d <> lv_degrees_d_7
If Math.Round ( gv_angle_a ) < lv_degrees_a_7 - 5 and Math.Round ( gv_angle_a ) < lv_degrees_a_7 Then
gv_angle_a = gv_angle_a + Math.Min ( lv_degrees_per_second_a_7 , lv_degrees_per_second_a_7 / 2 + ( lv_degrees_a_7 - gv_angle_a ) / 10 ) / 50
ElseIf Math.Round ( gv_angle_a ) > lv_degrees_a_7 + 5 and Math.Round ( gv_angle_a ) > lv_degrees_a_7 Then
gv_angle_a = gv_angle_a - Math.Max ( lv_degrees_per_second_a_7 , lv_degrees_per_second_a_7 / 2 + ( lv_degrees_a_7 - gv_angle_a ) / 10 ) / 50
Else
gv_angle_a = lv_degrees_a_7
EndIf
If Math.Round ( gv_angle_d ) < lv_degrees_d_7 Then
gv_angle_d = gv_angle_d + Math.Min ( lv_degrees_per_second_d_7 , lv_degrees_per_second_d_7 / 2 + ( lv_degrees_d_7 - gv_angle_d ) / 10 ) / 50
ElseIf Math.Round ( gv_angle_d ) > lv_degrees_d_7 Then
gv_angle_d = gv_angle_d - Math.Max ( lv_degrees_per_second_d_7 , lv_degrees_per_second_d_7 / 2 + ( lv_degrees_d_7 - gv_angle_d ) / 10 ) / 50
Else
gv_angle_d = lv_degrees_d_7
EndIf
Program.Delay ( 1 )
EndWhile
gv_angle_a = lv_degrees_a_7
gv_angle_d = lv_degrees_d_7
EndSub
Sub f_bmovea0_1
lv_degrees_8 = 0
lv_rotation_8 = lv_degrees_8 - gv_angle_a
lv_sign_8 = Math.Abs ( lv_rotation_8 ) / lv_rotation_8
lv_progress_8 = 0
lv_degrees_per_interval_8 = lv_degrees_per_second_8 * lv_sign_8 / 50
While Math.Abs ( lv_rotation_8 - lv_progress_8 ) > 5
gv_angle_a = gv_angle_a + lv_degrees_per_interval_8
lv_progress_8 = lv_progress_8 + lv_degrees_per_interval_8
Program.Delay ( 1 )
EndWhile
gv_angle_a = lv_degrees_8
EndSub
Sub f_bmoved0_1
lv_degrees_9 = 0
lv_rotation_9 = lv_degrees_9 - gv_angle_d
lv_sign_9 = Math.Abs ( lv_rotation_9 ) / lv_rotation_9
lv_progress_9 = 0
lv_degrees_per_interval_9 = lv_degrees_per_second_9 * lv_sign_9 / 50
While Math.Abs ( lv_rotation_9 - lv_progress_9 ) > 5
gv_angle_d = gv_angle_d + lv_degrees_per_interval_9
lv_progress_9 = lv_progress_9 + lv_degrees_per_interval_9
Program.Delay ( 1 )
EndWhile
gv_angle_d = lv_degrees_9
EndSub
