centro = 0
xtime = 0
ytime = 0
thetatime = 0
xtcorrect = 0
ytcorrect = 0
thetatcorrect = 0
Sentido_D = 1

Dw = 102
Diameter = 56
D_T = 0

include "includes\Movimiento_Recto_MotMed"

include "includes\Giro_MotMed"
include "includes\GirosPerfectos_MotMed"
include "includes\GirosUniversales_MotMed"

include "includes\Aceleracion_MotMed"
include "includes\Deceleracion_MotMed"

include "includes\Siguelineas_MotMed"
include "includes\Siguelineas_MotMed_Smart"

include "includes\Brazo"

include "includes\RGBRead"

Setup()
Thread.Run = Odometry
Thread.Run = Display
MainPrueba()


Sub Setup
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,4)
  Sensor.SetMode(3,4)
  Sensor.SetMode(4,0)
EndSub

Sub StartArm
  
  Time.Reset1()
  While Time.Get1() < 850
    MotorA.StartSpeed(30)
    MotorD.StartSpeed(30)
  EndWhile
  
  MotorAD.OffAndBrake()
  
  MotorA.ResetCount()
  MotorD.ResetCount()
  
  BMoveD(40,-360)
  
  MotorD.ResetCount()
  
  Program.Delay(100)
EndSub

'Subs de control paralelo

Function Kalman_Filter(in number[] velI_k1, in number[] velD_k1)
  
  itreal = 0
  radio = 56/2
  
  MultiMatrizCoef(velI_k1,-1,velI)
  MultiMatrizCoef(velD_k1,-1,velD)
  
  'Paso de velocidad a rad/s
  
  MultiMatrizCoef(velI_k1,1/56.12,omegaI_k1) #56.12
  MultiMatrizCoef(velD_k1,1/59.88,omegaD_k1) #59.88
  
  I = Vector.Data(9,"1 0 0  0 1 0  0 0 1")
  minus_1 = Vector.Data(9,"-1 0 0 0 -1 0 0 0 -1")
  
  Q_k1 = Vector.Data(3*3, "0.25 0 0  0 0.25 0 0 0 0.002")
  
  delta_t = EV3.Time
  old_t = 0
  
  old_I = -1*MotorB.GetTacho()
  old_D = -1*MotorC.GetTacho()
  
  log_file = EV3File.OpenWrite("WRO2024/log.txt")
  
  While omegaI_k1[itreal] <> 0 Or omegaD_k1[itreal] <> 0
    
    df_k = Vector.Init(3*3,0)
    
    #Matriz de estimaci贸n de posici贸n
    k_k1 = Vector.Init(3,0)
    
    #Matriz de posici贸n ajustada
    k1_k = Vector.Init(3,0)
    
    H = Vector.Init(3,0)
    
    dH = Vector.Init(9,0)
    
    R = Vector.Data(9,"0.25 0 0  0 0.25 0 0 0 0.002")
    
    #Matriz de valores de los sensores
    z = Vector.Init(3,0)
    
    delta_t = EV3.Time - old_t
    old_t = EV3.Time
    
    @D_T = delta_t
    
    Motor.StartSync("BC",velI[itreal],velD[itreal])
    
    k_k1[0] = k_k1[0] + ((omegaI_k1[itreal]+omegaD_k1[itreal])*radio*delta_t)/2*Math.Cos(k_k1[2]+((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(4*@Dw))
    k_k1[1] = k_k1[1] + ((omegaI_k1[itreal]+omegaD_k1[itreal])*radio*delta_t)/2*Math.Sin(k_k1[2]+((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(4*@Dw))
    k_k1[2] = k_k1[2] + ((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(2*@Dw)
    
    df_k[2] = -1*((omegaI_k1[itreal]+omegaD_k1[itreal])*radio*delta_t)/2*Math.Sin(k_k1[2]+((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(4*@Dw))
    df_k[2] = ((omegaI_k1[itreal]+omegaD_k1[itreal])*radio*delta_t)/2*Math.Cos(k_k1[2]+((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(4*@Dw))
    
    F_k = Vector.Add(3*3,I,df_k)
    
    U = Vector.Multiply(3,3,3,F_k,I)
    TraspMatVect3x3(U,V)
    W = Vector.Multiply(3,3,3,U,V)
    P_k_k1 = Vector.Add(3*3,W,Q_k1)
    
    H[0] = (k_k1[2] - k1_k[2])*delta_t
    H[1] = (Math.SquareRoot(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2)) - @Dw*(k_k1[2]-k1_k[2])) / radio
    H[2] = (Math.SquareRoot(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2)) + @Dw*(k_k1[2]-k1_k[2])) / radio
    
    dH[2] = 1/delta_t
    dH[3] = Math.Power(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2),-1/2)*(k_k1[0]-k1_k[0])/radio
    dH[4] = Math.Power(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2),-1/2)*(k_k1[1]-k1_k[1])/radio
    dH[5] = -@Dw/radio
    dH[6] = Math.Power(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2),-1/2)*(k_k1[0]-k1_k[0])/radio
    dH[7] = Math.Power(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2),-1/2)*(k_k1[1]-k1_k[1])/radio
    dH[8] = @Dw/radio
    
    z[0] = Sensor.ReadRawValue(2,0)
    z[1] = -1*MotorB.GetTacho() - old_I
    z[2] = -1*MotorC.GetTacho() - old_D
    
    minus_H = Vector.Multiply(1,3,3,H,minus_1)
    
    y = Vector.Add(3,z,minus_H)
    
    #Matriz S de covarianza residual
    S1 = Vector.Multiply(3,3,3,dH,P_k_k1)
    TraspMatVect3x3(dH,dH_T)
    S2 = Vector.Multiply(3,3,3,S1,dH_T)
    S = Vector.Add(9,S2,R)
    
    #Matriz K de ganancia de kalman
    K1 = Vector.Multiply(3,3,3,P_k_k1,dH_T)
    InvMatVect3x3(S,S_inv)
    K = Vector.Multiply(3,3,3,K1,S_inv)
    
    Ky = Vector.Multiply(3,3,3,K,y)
    
    k1_k = Vector.Add(9,k_k1,Ky)
    
    KH = Vector.Multiply(3,3,3,K,dH_T)
    minus_KH = Vector.Multiply(3,3,3,KH,minus_1)
    P1 = Vector.Multiply(3,3,3,I,minus_KH)
    
    #Matriz de covarianza actualizada
    P = Vector.Multiply(3,3,3,P1,P_k_k1)
    
    EV3File.WriteLine(log_file,"Medidas de entrada Izq: "+omegaI_k1[itreal])
    
    EV3File.WriteLine(log_file,"Medidas de entrada Dch: "+omegaD_k1[itreal])
    
    EV3File.WriteLine(log_file,"Sensor color: "+z[0])
    EV3File.WriteLine(log_file,"Encoder I: "+MotorB.GetTacho()*-1)
    EV3File.WriteLine(log_file,"Encoder D: "+MotorC.GetTacho()*-1)
    
    'For j = 0 To 8
      'EV3File.WriteLine(log_file,"Valor["+j+"] de P: "+P[j])
    'EndFor
    
    EV3File.WriteLine(log_file,"Iteraci贸n: "+itreal)
    EV3File.WriteLine(log_file,"Delta t: "+delta_t+" ms")
    
    EV3File.WriteLine(log_file,"---------------")
    EV3File.WriteLine(log_file,"")

    itreal ++
    
    old_I = -1*MotorB.GetTacho()
    old_D = -1*MotorC.GetTacho()
  EndWhile
  
EndFunction

Sub Odometry
  
  alpha_L[0] = 0
  alpha_R[0] = 0
  
  oldB = 0
  oldC = 0

  xt[0] = 0
  yt[0] = 0
  thetat[0] = 0

  i = 0
  While "True"

    alpha_L[i] = Math.GetRadians(MotorB.GetTacho()*-1)
    alpha_R[i] = Math.GetRadians(MotorC.GetTacho())
    
    
    d_L = (alpha_L[i]-alpha_L[i-1]) * Diameter/2
    d_R = (alpha_R[i]-alpha_R[i-1]) * Diameter/2

    d = (d_L + d_R) / 2

    delta_theta = (d_R - d_L) / (2 * Dw)

    xt[i+1] = (d * Math.Sin(thetat[i] + delta_theta / 2) + xt[i])
    
    yt[i+1] = (d * Math.Cos(thetat[i] + delta_theta / 2) + yt[i])
   
    thetat[i+1] = thetat[i] + delta_theta
    
    xtime = xt[i+1]
    ytime = yt[i+1]
    thetatime = thetat[i+1]
    
    i++

    Program.Delay(10)
    
  EndWhile
EndSub

Sub Display
  old_B = 0
  old_C = 0
  While "True"
    LCD.StopUpdate()
    LCD.Clear()
    
    LCD.Write(5,5,"xt: "+Math.Round(xt[i]*100)/100)
    LCD.Write(5,15,"yt: "+Math.Round(yt[i]*100)/100)
    LCD.Write(5,25,"thetat: "+math.getdegrees(thetat[i]))
    
    
    LCD.Write(5,35,"centro: "+centro)
    
    
    LCD.Write(5,45,"Velocidad de B:  "+MotorB.GetSpeed()*-1)
    LCD.Write(5,55,"Velocidad de C:  "+MotorC.GetSpeed())
    
    LCD.Write(5,65,"rad/s de B:  "+Math.GetRadians(MotorB.GetTacho()-old_B)/0.05*-1)
    LCD.Write(5,75,"rad/s de C:  "+Math.GetRadians(MotorC.GetTacho()-old_C)/0.05)
    
    LCD.Write(5,85,"Encoder de B:  "+MotorB.GetTacho()*-1)
    LCD.Write(5,95,"Encoder de C:  "+MotorC.GetTacho())
    
    LCD.Write(5,105,"Delta T:  "+D_T)
    
    
    'LCD.Write(5,75,"Angulo de A:  "+MotorA.GetTacho())
    'LCD.Write(5,85,"Obj de A:  "+angle_A)
    
    'LCD.Write(5,95,"Angulo de D:  "+MotorD.GetTacho())
    'LCD.Write(5,105,"Obj de D:  "+angle_D)
    
    'LCD.Write(5,115,"Sentido de D:  "+Sentido_D)
    LCD.Update()
    Program.Delay(50)
    old_B = MotorB.GetTacho()
    old_C = MotorC.GetTacho()
  EndWhile
EndSub

Sub DisplayVelocidades
  old_B = 0
  old_C = 0
  agg_B = 0
  agg_C = 0
  iteracion = 0
  While "True"
    iteracion++
    LCD.StopUpdate()
    LCD.Clear()
    
    LCD.Write(5,45,"Velocidad de B:  "+MotorB.GetSpeed()*-1)
    LCD.Write(5,55,"Velocidad de C:  "+MotorC.GetSpeed()*-1)
    
    rads_B = Math.GetRadians(MotorB.GetTacho()-old_B)/0.05*-1
    rads_C = Math.GetRadians(MotorC.GetTacho()-old_C)/0.05*-1
    
    agg_B += rads_B
    agg_C += rads_C
    
    media_B = agg_B/iteracion
    media_C = agg_C/iteracion
    
    LCD.Write(5,65,"rad/s de B: "+media_B)
    LCD.Write(5,75,"rad/s de C: "+media_C)
    
    LCD.Update()
    Program.Delay(50)
    old_B = MotorB.GetTacho()
    old_C = MotorC.GetTacho()
  EndWhile
EndSub

'Subs a ejecutar

Sub Main
  
  
  
  bomboclat = Row.Init(2,0)
  StartArm()
  
  EncoderRectoMM(30,10)
  Spin90(30)
  
  EncoderRectoMMF(30,10)
  Time.Reset2()
  SL1SPIDCross(30,0.3,0.0001,6,-1,1)
  
  If Time.Get2() > 1200 Then
    Caso_Arriba()
  Else
    Caso_Abajo()
  EndIf
  
  
EndSub

Sub MainPrueba
  
  StartArm()
  
  EncoderRectoMM(30,15)
  Lectura(floor)
  EncoderRectoMM(-30,5)
  
  Coger_Abajo()
  
  EncoderRectoMM(30,20)
  Lectura(floor)
  EncoderRectoMM(-30,6.5)
  
  Coger_Arriba()
  
  Program.Delay(4000)
  
  Soltar_Uno()
  
  EncoderRectoMM(-30,10)
  
  Soltar_Todo()
  
  BMoveAD0(30)
EndSub

Sub MainControlBrazo
  angle_A = 0
  angle_D = 0  
  
  While "True"
    If Buttons.Current = "U" Then
      angle_A -= 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "D" Then
      angle_A += 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "L" Then
      angle_D -= 1
      Program.Delay(1)
    ElseIf Buttons.Current = "R" Then
      angle_D += 1
      Program.Delay(1)
    EndIf
  EndWhile
EndSub

Sub MainControlRuedas
  vel_B = 92
  vel_C = 92
  
  While "True"
    If Buttons.Current = "U" Then
      vel_B -= 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "D" Then
      vel_B += 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "L" Then
      vel_C += 1
      Program.Delay(1)
    ElseIf Buttons.Current = "R" Then
      vel_C -= 1
      Program.Delay(1)
    EndIf
    Motor.StartSync("BC",-vel_B,-vel_C)
  EndWhile
EndSub

Sub Caso_Arriba
  
  rojos = 0
  amarillos = 0
  verdes = 0
  azules = 0
  
  SL14PIDEnc(30,0.3,0.0001,6,15)
  Spin90(30)
  
  'Se coloca frente a verde y azul
  
  EncoderRectoMM(30,15)
  
  Lectura(bloque)
  bomboclat[0] = bloque
  If bloque = 0 Then
    numero_bloques = 0
  Else
    numero_bloques = 1
    
    If bloque = 3 Then
      verdes ++
    Else
      azules ++
    EndIf
    
    EncoderRectoMM(-30,5)
    
    Coger_Abajo()
    
  EndIf
  
  'Gira al segundo
  
  EncoderRectoMM(-30,5)
  Spin90(30)
  
  EncoderRectoMM(30,12)
  Spin90(-30)
  
  EncoderRectoMM(30,15)
  Lectura(bloque)
  
  If bloque = 0 Then
    bomboclat[1] = bomboclat[0]
    
    bomboclat[0] = 0
  Else
    bomboclat[1] = bloque
    numero_bloques ++
    
    If numero_bloques = 1 Then
      
      Coger_Abajo()
      
    Else
    
      Coger_Arriba()
    EndIf
    
  EndIf
  'Se jubila
  
  1BlancoRectoMM(-30,1)
  1NegroRectoMM(-30,1)
  
  GPerfDDEFINITIVOMM(30)
  
  SL1SPIDCross(30,0.3,0.0001,6,1,4)
  SL14PIDEnc(30,0.3,0.0001,5,25)
  
  If numero_bloques > 0 Then
    
    Spin90(30)
    EncoderRectoMM(30,20)
    
    If bomboclat[1] = 2 Then
      
      'bloque azul abajo 
      
      GUnivEncMM(30,0,35)
      BMoveA(10,-800)
      BMoveDSafe(40,-200)
      
      numero_bloques --
      
      If numero_bloques = 2 and bomboclat[0] = 3 Then
        
        'azul y verde
        
        BMoveA(10,-750)
        BMoveDSafe(40,-250)
        BMoveDTimer(-40,200)
        
        BMoveA(30,-500)
        
        GUnivEncMM(-30,0,35)
        GUnivEncMM(0,30,35)
        
        BMoveA(10,-800)
        BMoveDSafe(40,-200)
        
        numero_bloques = 0
        GUnivEncMM(0,-30,35)
        
      Else
        
        'uno o dos azules
        
        numero_bloques = 0
        BMoveAD0(30)
        GUnivEncMM(-30,0,35)

      EndIf
      

    ElseIf bomboclat[1] = 3 Then
      
      'abajo verde
      
      GUnivEncMM(0,30,35)
      BMoveA(10,-800)
      BMoveDSafe(40,-200)
      
      numero_bloques --
    
      If numero_bloques = 2 and bomboclat[0] = 2 Then
        
        'verde y azul
        
        BMoveA(10,-750)
        BMoveDSafe(40,-250)
        BMoveDTimer(-40,200)
        
        BMoveA(30,-500)
        
        GUnivEncMM(0,-30,35)
        GUnivEncMM(30,0,35)
        
        BMoveA(10,-800)
        BMoveDSafe(40,-200)
        
        numero_bloques = 0
        
        BMoveAD0(30)
        GUnivEncMM(-30,0,35)
        
      Else
        
        'uno o dos verdes
        
        numero_bloques = 0
        BMoveAD0(30)
        GUnivEncMM(0,-30,35)

      EndIf
      
    EndIf
    
    EncoderRectoMM(-30,10)
    Spin180(30)
    
    1BlancoRectoMM(-30,1)
    1NegroRectoMM(-30,1)
    
    EncoderRectoMM(30,5)
  Else
    Spin90(-30)
  EndIf
  
EndSub

Sub Caso_Abajo
EndSub

Function Coger_Abajo()
  
  'Coge el primero
  
  BMoveD(40,-250)
  BMoveA(20,-700)
  BMoveDTimer(-40,200)
  BMoveA(20,-300)
  
EndFunction

Function Coger_Arriba()
  
  BMoveA(10,-600)
  
  'Coge el segundo
  
  BMoveD(20,-200)
  BMoveA(10,-650)
  
  BMoveDSafe(40,-250)
  BMoveA(20,-700)
  BMoveDTimer(-40,200)
  BMoveA(20,-300)
  
EndFunction

Function Soltar_Todo()
  
  BMoveA(10,-700)
  BMoveDSafe(40,-200)
  
  BMoveA(10,-500)
  
EndFunction

Function Soltar_Uno()
  
  BMoveA(10,-700)
  BMoveDSafe(40,-200)
  BMoveA(10,-630)
  BMoveDSafe(40,-250)
  BMoveDTimer(-40,200)
  
  BMoveA(10,-500)
  
EndFunction

Function ToXY_Basic(in number Velocidad, in number x, in number y, in number theta)
  
  I = "B"
  D = "C"
  
  ' Constante que relaciona los grados de encoder necesarios para girar 1 grado en spin
  G1 = 110/36
  
  Signo = -1
  
  diff_x = x - @xtime
  diff_y = y - @ytime
  
  angulo_giro_inicial = Math.getDegrees(Math.ArcTan((x-@xtime)/(y-@ytime)))
  
  @angulo = angulo_giro_inicial
  If diff_y < 0 Then
    If diff_x < 0 Then
			angulo_giro_inicial = angulo_giro_inicial - 180 - @thetatime
		ElseIf diff_x > 0 Then
			angulo_giro_inicial = 0 - @thetatime - angulo_giro_inicial
    EndIf
  EndIf
  
  If angulo_giro_inicial > 0 Then
    V1 = Velocidad
    V2 = Velocidad * -1
  Else
    V1 = Velocidad * -1
    V2 = Velocidad
  EndIf
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = angulo_giro_inicial * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1/2, -V2/2, Encodr, "True")
  
  distancia =  Math.SquareRoot(diff_x*diff_x + diff_y*diff_y)

  Enc = distancia*360 / Math.Pi / @Diameter
  
  encoder_B_inicial = Motor.GetCount ("B")
  encoder_C_inicial = Motor.GetCount ("C")

  While Math.abs(Motor.GetCount ("C") - encoder_C_inicial) < Enc
    
    encoder_B = Motor.GetCount ("B") - encoder_B_inicial
    encoder_C = Motor.GetCount ("C") - encoder_C_inicial
    
    error = encoder_B - encoder_C

    proporcional = error*2

    Motor.StartSync("BC", (Velocidad-proporcional), -(Velocidad+proporcional))

  EndWhile

  Motor.Stop("BC", "True")
  
  angulo_giro_final = theta - Math.GetDegrees(@thetatime)
  
  If angulo_giro_final > 0 Then
    V1 = Velocidad
    V2 = Velocidad * -1
  Else
    V1 = Velocidad * -1
    V2 = Velocidad
  EndIf
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = angulo_giro_final * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1/2, -V2/2, Encodr, "True")
  @xtcorrect = x
  @ytcorrect = y
  @thetatcorrect = math.getradians(theta)
  
EndFunction

Function ToXY_Giro(in number Velocidad, in number x, in number y, in number theta)
EndFunction

Function Lectura(out number read)
  BmoveA(15,-600)
  RGBDetect2(5,read)
  LeerColor(read)
  BmoveA(15,-450)
EndFunction

Function TraspMatVect3x3(in number[] M, out number[] S)
  
  S = Vector.Init(3*3,0)
  
  S[0] = M[0] 
  S[1] = M[3] 
  S[2] = M[6] 
  
  S[3] = M[1] 
  S[4] = M[4] 
  S[5] = M[7] 
  
  S[6] = M[2] 
  S[7] = M[5] 
  S[8] = M[8] 
  
EndFunction

Function InvMatVect3x3(in number[] M, out number[] S)
  
  'Hallamos determinante
  
  Determinante = M[0]*(M[4]*M[8]-M[5]*M[7]) - M[1]*(M[3]*M[8]-M[5]*M[6]) + M[2]*(M[3]*M[7]-M[4]*M[6])
  If Determinante <> 0 Then
    
    S[0] = (M[4]*M[8]-M[5]*M[7]) / Determinante
    S[1] = (M[3]*M[8]-M[5]*M[6]) / Determinante
    S[2] = (M[3]*M[7]-M[4]*M[6]) / Determinante
    
    S[3] = (M[1]*M[8]-M[2]*M[7]) / Determinante
    S[4] = (M[0]*M[8]-M[2]*M[6]) / Determinante
    S[5] = (M[0]*M[7]-M[1]*M[6]) / Determinante
    
    S[6] = (M[1]*M[5]-M[2]*M[4]) / Determinante
    S[7] = (M[0]*M[5]-M[2]*M[3]) / Determinante
    S[8] = (M[0]*M[4]-M[1]*M[3]) / Determinante
    
  EndIf
  
EndFunction

Function MultiMatrizCoef(in number[] M, in number k, out number[] S)
  
  i = 0
  
  While M[i] <> 0
    
    S[i] = k * M[i]
    
    i++
  EndWhile
  
EndFunction