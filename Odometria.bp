centro = 0
xtime = 0
ytime = 0
thetatime = 0
xtcorrect = 0
ytcorrect = 0
thetatcorrect = 0
Sentido_D = 1
D_T = 0


include "includes\Aceleracion_MotGran"
include "includes\Movimiento_Recto_MotGran"

Thread.Run = PIDControl_AD
Thread.Run = Odometry
Thread.Run = Display
Main()
Program.Delay(10000)

Sub StartArm

  angle_A = 0
  angle_D = 0
  
  Time.Reset1()
  While Time.Get1() <500
    angle_D ++
    Program.Delay(3)
  EndWhile
  Program.Delay(500)
  If Math.Abs(Motor.GetCount("D")) < 60 Then
    BMoveD0(90)
    Sentido_D = -1
  Else
    BMoveD0(90)
    Sentido_D = 1
  EndIf
  
  BMoveA0(90)
  
  Program.Delay(100)
EndSub

'Subs de control paralelo

Function Kalman_Filter(in number omegaI_k1, in number omegaD_k1)
  
  radio = 56/2
  
  P = Vector.Data(3*3,"1 0 0  0 1 0  0 0 1")
  
  df_k = Vector.Init(3*3,0)
  
  'P1[0] = 1
  'P1[1] = 0
  'P1[2] = 0
  
  'P2[0] = 0
  'P2[1] = 1
  'P2[2] = 0
  
  'P3[0] = 0
  'P3[1] = 0
  'P3[2] = 1
  
  x_k_k1 = 0
  y_k_k1 = 0
  theta_k_k1 = 0
  
  delta_t = EV3.Time
  old_t = 0
  While "True"
    delta_t = EV3.Time - old_t
    old_t = EV3.Time
    x_k_k1 = x_k_k1 + ((omegaI_k1+omegaD_k1)*radio*delta_t)/2*Math.Cos(theta_k_k1+((omegaD_k1-omegaI_k1)*radio*delta_t)/(4*@Dw))
    y_k_k1 = y_k_k1 + ((omegaI_k1+omegaD_k1)*radio*delta_t)/2*Math.Sin(theta_k_k1+((omegaD_k1-omegaI_k1)*radio*delta_t)/(4*@Dw))
    theta_k_k1 = theta_k_k1 + ((omegaD_k1-omegaI_k1)*radio*delta_t)/(2*@Dw)
    
    'F_k_x[0] = 1
    'F_k_x[1] = 0
    'F_k_x[2] = -1*((omegaI_k1+omegaD_k1)*radio*delta_t)/2*Math.Sin(theta_k_k1+((omegaD_k1-omegaI_k1)*radio*delta_t)/(4*@Dw))
    
    'F_k_y[0] = 0
    'F_k_y[1] = 1
    'F_k_y[2] = ((omegaI_k1+omegaD_k1)*radio*delta_t)/2*Math.Cos(theta_k_k1+((omegaD_k1-omegaI_k1)*radio*delta_t)/(4*@Dw))
    
    'F_k_theta[0] = 0
    'F_k_theta[1] = 0
    'F_k_theta[2] = 1
    
    df_k[2] = -1*((omegaI_k1+omegaD_k1)*radio*delta_t)/2*Math.Sin(theta_k_k1+((omegaD_k1-omegaI_k1)*radio*delta_t)/(4*@Dw))
    df_k[2] = ((omegaI_k1+omegaD_k1)*radio*delta_t)/2*Math.Cos(theta_k_k1+((omegaD_k1-omegaI_k1)*radio*delta_t)/(4*@Dw))
    
    F_k = Vector.Add(3*3,P,df_k)
    
    Q_k1 = Vector.Data(3*3, "0.25 0 0  0 0.25 0 0 0 0.002")
    
    'Q_x_k1[0] = 0.5*0.5
    'Q_x_k1[1] = 0
    'Q_x_k1[2] = 0
    
    'Q_y_k1[0] = 0
    'Q_y_k1[1] = 0.5*0.5
    'Q_y_k1[2] = 0
    
    'Q_theta_k1[0] = 0
    'Q_theta_k1[1] = 0
    'Q_theta_k1[2] = Math.GetRadians(3)*Math.GetRadians(3)
    
    @D_T = delta_t
    
    'MultiMatrices3x3(F_k_x,F_k_y,F_k_theta,P1,P2,P3,U1,U2,U3)
    'TraspMatriz3x3(F_k_x,F_k_y,F_k_theta,V1,V2,V3)
    'MultiMatrices3x3(U1,U2,U3,V1,V2,V3,W1,W2,W3)
    'SumaMatrices3x3(W1,W2,W3,Q_x_k1,Q_y_k1,Q_theta_k1,P1,P2,P3)
    
    U = Vector.Multiply(3,3,3,F_k,P)
    TraspMatVect3x3(U,V)
    W = Vector.Multiply(3,3,3,U,V)
    P = Vector.Add(3*3,W,Q_k1)
    
  EndWhile
  
EndFunction

Sub Odometry
  
  alpha_L[0] = 0
  alpha_R[0] = 0
  
  oldB = 0
  oldC = 0

  xt[0] = 0
  yt[0] = 0
  thetat[0] = 0

  i = 0
  While "True"
    
    Dw = 84.5

    Diameter = 56

    alpha_L[i] = Math.GetRadians(MotorB.GetTacho())
    alpha_R[i] = Math.GetRadians(MotorC.GetTacho())
    
    
    d_L = (alpha_L[i]-alpha_L[i-1]) * Diameter/2
    d_R = (alpha_R[i]-alpha_R[i-1]) * Diameter/2

    d = (d_L + d_R) / 2

    delta_theta = (d_R - d_L) / (2 * Dw)

    If xtcorrect <> 0 Then
      xt[i+1] = xtcorrect
      xtcorrect = 0
    Else
      xt[i+1] = (d * Math.Sin(thetat[i] + delta_theta / 2) + xt[i])*-1
    EndIf
    
    If ytcorrect <> 0 Then
      yt[i+1] = ytcorrect
      ytcorrect = 0
    Else
      yt[i+1] = (d * Math.Cos(thetat[i] + delta_theta / 2) + yt[i])*-1
    EndIf
    
    If thetatcorrect <> 0 Then
      thetat[i+1] = thetatcorrect
      thetatcorrect = 0
    Else
      thetat[i+1] = thetat[i] + delta_theta
    EndIf
    
    xtime = xt[i+1]
    ytime = yt[i+1]
    thetatime = thetat[i+1]
    
    i++
    
    
    Program.Delay(10)
    
  EndWhile
EndSub

Sub PIDControl_AD
  
  kp_A = 0.5
  ki_A = 0.0001
  kd_A = 0.1
  
  kp_D = 0.5
  ki_D = 0.0001
  kd_D = 0.1
  
  error_A = 0
  error_D = 0
  
  errsum_A = 0
  errsum_D = 0
  
  oldError_A = 0
  oldError_D = 0
  
  u_A = 0
  u_D = 0
  
  angle_A = 0
  angle_D = 0
  
  While "True"
    
    error_A = angle_A - MotorA.GetTacho()
    errsum_A += error_A
    u_A = (error_A * kp_A) + (errsum_A * ki_A/1) + ((error_A - oldError_A) * kd_A)
    
    MotorA.StartSpeed(u_A)
    
    error_D = angle_D - MotorD.GetTacho()
    errsum_D += error_D
    u_D = (error_D * kp_D) + (errsum_D * ki_D/1) + ((error_D - oldError_D) * kd_D) * Sentido_D
    
    MotorD.StartSpeed(u_D)
    
  EndWhile

EndSub

Sub Display
  While "True"
    LCD.StopUpdate()
    LCD.Clear()
    LCD.Write(5,5,"xt: "+Math.Round(xt[i]*100)/100)
    LCD.Write(5,15,"yt: "+Math.Round(yt[i]*100)/100)
    LCD.Write(5,25,"thetat: "+math.getdegrees(thetat[i]))
    LCD.Write(5,35,"centro: "+centro)
    'LCD.Write(5,45,"Velocidad de B:  "+MotorB.GetSpeed()*-1)
    'LCD.Write(5,55,"Velocidad de C:  "+MotorC.GetSpeed()*-1)
    LCD.Write(5,45,"Delta T:  "+D_T)
    LCD.Write(5,75,"Angulo de A:  "+MotorA.GetTacho())
    LCD.Write(5,85,"Obj de A:  "+angle_A)
    LCD.Write(5,95,"Angulo de D:  "+MotorD.GetTacho())
    LCD.Write(5,105,"Obj de D:  "+angle_D)
    LCD.Write(5,115,"Sentido de D:  "+Sentido_D)
    LCD.Update()
    Program.Delay(50)
  EndWhile
EndSub

'Subs a ejecutar

Sub Main
  Kalman_Filter(1,1)
  StartArm()
  GUnivEncMG(0,20,40)
  GUnivEncMG(20,0,40)
  BMoveD(90,140)
  EncoderRectoMG(30,80)
  BMoveD0(90)
  BMoveA(90,180)
  EncoderRectoMG(-30,30)
  GUnivEncMG(20,-20,60)
  EncoderRectoMG(30,60)
  GUnivEncMG(-20,20,55)
  BMoveAD(90,90,60,160)
  Program.Delay(1000)
  EncoderRectoMG(-30,200)
  BMoveAD0(90,90)
EndSub

Sub Main2
  BMoveAD(150,150,180,-30)
  BMoveD(50,150)
  Program.Delay(1000)
  BMoveA(40,135)
  Program.Delay(2500)
  BMoveAD(150,100,162,20)
  BMoveD0(100)
  BMoveA(150,150)
  BMoveA(150,170)
  BMoveA0(150)
  Program.Delay(2000)
EndSub

Sub MainControl
  angle_A = 0
  angle_D = 0  
  
  While "True"
    If Buttons.Current = "U" Then
      angle_A -= 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "D" Then
      angle_A += 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "L" Then
      angle_D -= 1
      Program.Delay(1)
    ElseIf Buttons.Current = "R" Then
      angle_D += 1
      Program.Delay(1)
    EndIf
  EndWhile
EndSub


Function ToXY_Basic(in number Velocidad, in number x, in number y, in number theta)
  
  I = "B"
  D = "C"
  
  ' Constante que relaciona los grados de encoder necesarios para girar 1 grado en spin
  G1 = 110/36
  
  Signo = -1
  
  diff_x = x - @xtime
  diff_y = y - @ytime
  
  angulo_giro_inicial = Math.getDegrees(Math.ArcTan((x-@xtime)/(y-@ytime)))
  
  If angulo_giro_inicial > 0 Then
    V1 = Velocidad
    V2 = Velocidad * -1
  Else
    V1 = Velocidad * -1
    V2 = Velocidad
  EndIf
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = angulo_giro_inicial * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1/2, -V2/2, Encodr, "True")
  
  distancia =  Math.SquareRoot(diff_x*diff_x + diff_y*diff_y)

  Enc = distancia*360 / Math.Pi / @Diameter
  
  encoder_B_inicial = Motor.GetCount ("B")
  encoder_C_inicial = Motor.GetCount ("C")

  While Math.abs(Motor.GetCount ("C") - encoder_C_inicial) < Enc
    
    encoder_B = Motor.GetCount ("B") - encoder_B_inicial
    encoder_C = Motor.GetCount ("C") - encoder_C_inicial
    
    error = encoder_B - encoder_C

    proporcional = error*2

    Motor.StartSync("BC", (Velocidad-proporcional), -(Velocidad+proporcional))

  EndWhile

  Motor.Stop("BC", "True")
  
  angulo_giro_final = theta - Math.GetDegrees(@thetatime)
  
  If angulo_giro_final > 0 Then
    V1 = Velocidad
    V2 = Velocidad * -1
  Else
    V1 = Velocidad * -1
    V2 = Velocidad
  EndIf
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = angulo_giro_final * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1/2, -V2/2, Encodr, "True")
  @xtcorrect = x
  @ytcorrect = y
  @thetatcorrect = math.getradians(theta)
  
EndFunction

Function GUnivEncMG(in number V1, in number V2, in number Angle)
  I = "B"
  D = "C"
  
  ' Constante que relaciona los grados de encoder necesarios para girar 1 grado en spin
  G1 = 110/36
  
  Signo = (V1 / V2) / Math.Abs(V1 / V2)
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = Angle * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1, -V2, Encodr, "True")
  
EndFunction

Function ToXY_Giro(in number Velocidad, in number x, in number y, in number theta)
EndFunction


Function SumaMatrices3x3(in number[] M1, in number[] M2, in number[] M3, in number[] N1, in number[] N2, in number[] N3, out number[] S1, out number[] S2, out number[] S3)
  
  S1[0] = M1[0] + N1[0]
  S1[1] = M1[1] + N1[1]
  S1[2] = M1[2] + N1[2]
  
  S2[0] = M2[0] + N2[0]
  S2[1] = M2[1] + N2[1]
  S2[2] = M2[2] + N2[2]
  
  S3[0] = M3[0] + N3[0]
  S3[1] = M3[1] + N3[1]
  S3[2] = M3[2] + N3[2]
  
EndFunction

Function TraspMatriz3x3(in number[] M1, in number[] M2, in number[] M3, out number[] S1, out number[] S2, out number[] S3)
  
  S1[0] = M1[0] 
  S1[1] = M2[0] 
  S1[2] = M3[0] 
  
  S2[0] = M1[1] 
  S2[1] = M2[1] 
  S2[2] = M3[1] 
  
  S3[0] = M1[2] 
  S3[1] = M2[2] 
  S3[2] = M3[2] 
  
EndFunction

Function TraspMatVect3x3(in number[] M, out number[] S)
  
  S = Vector.Init(3*3,0)
  
  S[0] = M[0] 
  S[1] = M[3] 
  S[2] = M[6] 
  
  S[3] = M[1] 
  S[4] = M[4] 
  S[5] = M[7] 
  
  S[6] = M[2] 
  S[7] = M[5] 
  S[8] = M[8] 
  
EndFunction

Function MultiMatrices3x3(in number[] M1, in number[] M2, in number[] M3, in number[] N1, in number[] N2, in number[] N3, out number[] S1, out number[] S2, out number[] S3)
  
  S1[0] = M1[0] * N1[0] + M1[1] * N2[0] + M1[2] * N3[0]
  S1[1] = M1[0] * N1[1] + M1[1] * N2[1] + M1[2] * N3[1]
  S1[2] = M1[0] * N1[2] + M1[1] * N2[2] + M1[2] * N3[2]
  
  S2[0] = M2[0] * N1[0] + M2[1] * N2[0] + M2[2] * N3[0]
  S2[1] = M2[0] * N1[1] + M2[1] * N2[1] + M2[2] * N3[1]
  S2[2] = M2[0] * N1[2] + M2[1] * N2[2] + M2[2] * N3[2]
  
  S3[0] = M3[0] * N1[0] + M3[1] * N2[0] + M3[2] * N3[0]
  S3[1] = M3[0] * N1[1] + M3[1] * N2[1] + M3[2] * N3[1]
  S3[2] = M3[0] * N1[2] + M3[1] * N2[2] + M3[2] * N3[2]
  
EndFunction

Function InvMatriz3x3(in number[] M1, in number[] M2, in number[] M3, out number[] S1, out number[] S2, out number[] S3)
  
  'Hallamos determinante
  
  Determinante = M1[0]*(M2[1]*M3[2]-M2[2]*M3[1]) - M1[1]*(M2[0]*M3[2]-M2[2]*M3[0]) + M1[2]*(M2[0]*M3[1]-M2[1]*M3[0])
  If Determinante <> 0 Then
    
    S1[0] = (M2[1]*M3[2]-M2[2]*M3[1]) / Determinante
    S1[1] = (M2[0]*M3[2]-M2[2]*M3[0]) / Determinante
    S1[2] = (M2[0]*M3[1]-M2[1]*M3[0]) / Determinante
    
    S2[0] = (M1[1]*M3[2]-M1[2]*M3[1]) / Determinante
    S2[1] = (M1[0]*M3[2]-M1[2]*M3[0]) / Determinante
    S2[2] = (M1[0]*M3[1]-M1[1]*M3[0]) / Determinante
    
    S3[0] = (M1[1]*M2[2]-M1[2]*M2[1]) / Determinante
    S3[1] = (M1[0]*M2[2]-M1[2]*M2[0]) / Determinante
    S3[2] = (M1[0]*M2[1]-M1[1]*M2[0]) / Determinante
    
  EndIf
  
EndFunction

Function BMoveA(in number degrees_per_second, in number degrees)
  
  #Para usar con control PID en paralelo
  
  rotation = degrees - @angle_A
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_A += degrees_per_interval
    progress += degrees_per_interval

    Program.Delay(1)
    
  EndWhile
  @angle_A = degrees
EndFunction

Function BMoveAPesado(in number degrees_per_second, in number degrees)
  
  #Para usar con control PID en paralelo
  
  old_kp_A = @kp_A
  old_ki_A = @ki_A
  old_kd_A = @kd_A
  
  @kp_A *= 15
  @ki_A *= 15
  @kd_A *= 15
  
  rotation = degrees - @angle_A
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_A += degrees_per_interval
    progress += degrees_per_interval

    Program.Delay(1)
    
  EndWhile
  @angle_A = degrees
  
  @kp_A = old_kp_A
  @ki_A = old_ki_A
  @kd_A = old_kd_A
EndFunction

Function BMoveD(in number degrees_per_second, in number degrees)
  
  #Para usar con control PID en paralelo
  
  degrees *= @Sentido_D
  rotation = degrees - @angle_D
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_D += degrees_per_interval
    progress += degrees_per_interval
    
    Program.Delay(1)
    
  EndWhile
  @angle_D = degrees
EndFunction

Function BMoveAD(in number degrees_per_second_A, in number degrees_per_second_D, in number degrees_A, in number degrees_D)
  
  #Para usar con control PID en paralelo
  
  degrees_D *= @Sentido_D
  While @angle_A <> degrees_A Or @angle_D <> degrees_D
    
    If Math.Round(@angle_A) < degrees_A - 5 and Math.Round(@angle_A) < degrees_A Then
      @angle_A += Math.Min(degrees_per_second_A, degrees_per_second_A/2 + (degrees_A - @angle_A) / 10)/50
    ElseIf Math.Round(@angle_A) > degrees_A + 5 and Math.Round(@angle_A) > degrees_A Then
      @angle_A -= Math.Max(degrees_per_second_A, degrees_per_second_A/2 + (degrees_A - @angle_A) / 10)/50
    Else
      @angle_A = degrees_A
    EndIf
    
    If Math.Round(@angle_D) < degrees_D Then
      @angle_D += Math.Min(degrees_per_second_D, degrees_per_second_D/2 + (degrees_D - @angle_D) / 10)/50
    ElseIf Math.Round(@angle_D) > degrees_D Then
      @angle_D -= Math.Max(degrees_per_second_D, degrees_per_second_D/2 + (degrees_D - @angle_D) / 10)/50
    Else
      @angle_D = degrees_D
    EndIf
    
    Program.Delay(1)
  EndWhile
  @angle_A = degrees_A  
  @angle_D = degrees_D
  
EndFunction

Function BMoveA0(in number degrees_per_second)
  
  #Para usar con control PID en paralelo
  
  degrees = 0
  rotation = degrees - @angle_A
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_A += degrees_per_interval
    progress += degrees_per_interval

    Program.Delay(1)
    
  EndWhile
  @angle_A = degrees
EndFunction

Function BMoveD0(in number degrees_per_second)
  
  #Para usar con control PID en paralelo
  
  degrees = 0
  rotation = degrees - @angle_D
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_D += degrees_per_interval
    progress += degrees_per_interval
    
    Program.Delay(1)
    
  EndWhile
  @angle_D = degrees
EndFunction

Function BMoveAD0(in number degrees_per_second_A, in number degrees_per_second_D)
  
  #Para usar con control PID en paralelo
  
  degrees_A = 0
  degrees_D = 0
  
  While @angle_A <> degrees_A Or @angle_D <> degrees_D
    
    If Math.Round(@angle_A) < degrees_A Then
      @angle_A += Math.Min(degrees_per_second_A, degrees_per_second_A/2 + (degrees_A - @angle_A) / 10)/50
    ElseIf Math.Round(@angle_A) > degrees_A Then
      @angle_A -= Math.Max(degrees_per_second_A, degrees_per_second_A/2 + (degrees_A - @angle_A) / 10)/50
    Else
      @angle_A = degrees_A
    EndIf
    
    If Math.Round(@angle_D) < degrees_D Then
      @angle_D += Math.Min(degrees_per_second_D, degrees_per_second_D/2 + (degrees_D - @angle_D) / 10)/50
    ElseIf Math.Round(@angle_D) > degrees_D Then
      @angle_D -= Math.Max(degrees_per_second_D, degrees_per_second_D/2 + (degrees_D - @angle_D) / 10)/50
    Else
      @angle_D = degrees_D
    EndIf
    
    Program.Delay(1)
  EndWhile
  @angle_A = degrees_A  
  @angle_D = degrees_D
  
EndFunction

