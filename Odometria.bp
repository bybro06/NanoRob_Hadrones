centro = 0
xtime = 0
ytime = 0
thetatime = 0
xtcorrect = 0
ytcorrect = 0
thetatcorrect = 0
Sentido_D = 1

StartArm()

Thread.Run = PIDControl_AD
Thread.Run = Odometry
Thread.Run = Display
Main()
Program.Delay(10000)

Sub StartArm
  BMoveAD(200,200,-200,200)
  Program.Delay(1000)

  Motor.ResetCount("A")
  Motor.ResetCount("D")
  angle_A = 0
  angle_D = 0
  
  Time.Reset1()
  While Time.Get1() <500
    angle_D ++
    Program.Delay(5)
  EndWhile
  
  If Math.Abs(Motor.GetCount("D")) < 60 Then
    BMoveD0(90)
    Sentido_D = 1
  Else
    BMoveD0(90)
    Sentido_D = -1
  EndIf
  
  Program.Delay(100)
EndSub

'Subs de control paralelo

Sub Odometry
  
  alpha_L[0] = 0
  alpha_R[0] = 0
  
  oldB = 0
  oldC = 0

  xt[0] = 0
  yt[0] = 0
  thetat[0] = 0

  i = 0
  While "True"
    
    Dw = 84.5

    Diameter = 56

    alpha_L[i] = Math.GetRadians(MotorB.GetTacho())
    alpha_R[i] = Math.GetRadians(MotorC.GetTacho())
    
    
    d_L = (alpha_L[i]-alpha_L[i-1]) * Diameter/2
    d_R = (alpha_R[i]-alpha_R[i-1]) * Diameter/2

    d = (d_L + d_R) / 2

    delta_theta = (d_R - d_L) / (2 * Dw)

    If xtcorrect <> 0 Then
      xt[i+1] = xtcorrect
      xtcorrect = 0
    Else
      xt[i+1] = (d * Math.Sin(thetat[i] + delta_theta / 2) + xt[i])*-1
    EndIf
    
    If ytcorrect <> 0 Then
      yt[i+1] = ytcorrect
      ytcorrect = 0
    Else
      yt[i+1] = (d * Math.Cos(thetat[i] + delta_theta / 2) + yt[i])*-1
    EndIf
    
    If thetatcorrect <> 0 Then
      thetat[i+1] = thetatcorrect
      thetatcorrect = 0
    Else
      thetat[i+1] = thetat[i] + delta_theta
    EndIf
    
    xtime = xt[i+1]
    ytime = yt[i+1]
    thetatime = thetat[i+1]
    
    i++
    
    
    Program.Delay(10)
    
  EndWhile
EndSub

Sub PIDControl_AD
  
  kp_A = 0.5
  ki_A = 0.0001
  kd_A = 0.1
  
  kp_D = 0.5
  ki_D = 0.0001
  kd_D = 0.1
  
  error_A = 0
  error_D = 0
  
  errsum_A = 0
  errsum_D = 0
  
  oldError_A = 0
  oldError_D = 0
  
  u_A = 0
  u_D = 0
  
  angle_A = 0
  angle_D = 0
  
  While "True"
    
    error_A = angle_A - MotorA.GetTacho()
    errsum_A += error_A
    u_A = (error_A * kp_A) + (errsum_A * ki_A/1) + ((error_A - oldError_A) * kd_A)
    
    MotorA.StartSpeed(u_A)
    
    error_D = angle_D - MotorD.GetTacho()
    errsum_D += error_D
    u_D = (error_D * kp_D) + (errsum_D * ki_D/1) + ((error_D - oldError_D) * kd_D) * Sentido_D
    
    MotorD.StartSpeed(u_D)
    
  EndWhile

EndSub

Sub Display
  While "True"
    LCD.StopUpdate()
    LCD.Clear()
    LCD.Write(5,5,"xt: "+Math.Round(xt[i]*100)/100)
    LCD.Write(5,15,"yt: "+Math.Round(yt[i]*100)/100)
    LCD.Write(5,25,"thetat: "+math.getdegrees(thetat[i]))
    LCD.Write(5,35,"centro: "+centro)
    LCD.Write(5,65,"Angulo de A:  "+MotorA.GetTacho())
    LCD.Write(5,75,"Obj de A:  "+angle_A)
    LCD.Write(5,85,"Angulo de D:  "+MotorD.GetTacho())
    LCD.Write(5,95,"Obj de D:  "+angle_D)
    LCD.Update()
    Program.Delay(50)
  EndWhile
EndSub

'Subs a ejecutar

Sub Main
  
  
  ToXY_Basic(30,-300,500,-90)
  ToXY_Basic(30,0,0,0)

EndSub

Sub Main2
  BMoveAD(150,150,180,-30)
  BMoveD(50,150)
  Program.Delay(1000)
  BMoveA(40,135)
  Program.Delay(2500)
  BMoveAD(150,100,162,20)
  BMoveD0(100)
  BMoveA(150,150)
  BMoveA(150,170)
  BMoveA0(150)
  Program.Delay(2000)
EndSub

Sub MainControl
  angle_A = 0
  angle_D = 0  
  
  While "True"
    If Buttons.Current = "U" Then
      angle_A -= 1
      Program.Delay(1)
    ElseIf Buttons.Current = "D" Then
      angle_A += 1
      Program.Delay(1)
    ElseIf Buttons.Current = "L" Then
      angle_D -= 1
      Program.Delay(1)
    ElseIf Buttons.Current = "R" Then
      angle_D += 1
      Program.Delay(1)
    EndIf
  EndWhile
EndSub


Function ToXY_Basic(in number Velocidad, in number x, in number y, in number theta)
  
  I = "B"
  D = "C"
  
  ' Constante que relaciona los grados de encoder necesarios para girar 1 grado en spin
  G1 = 110/36
  
  Signo = -1
  
  diff_x = x - @xtime
  diff_y = y - @ytime
  
  angulo_giro_inicial = Math.getDegrees(Math.ArcTan((x-@xtime)/(y-@ytime)))
  
  If angulo_giro_inicial > 0 Then
    V1 = Velocidad
    V2 = Velocidad * -1
  Else
    V1 = Velocidad * -1
    V2 = Velocidad
  EndIf
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = angulo_giro_inicial * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1/2, -V2/2, Encodr, "True")
  
  distancia =  Math.SquareRoot(diff_x*diff_x + diff_y*diff_y)

  Enc = distancia*360 / Math.Pi / @Diameter
  
  encoder_B_inicial = Motor.GetCount ("B")
  encoder_C_inicial = Motor.GetCount ("C")

  While Math.abs(Motor.GetCount ("C") - encoder_C_inicial) < Enc
    
    encoder_B = Motor.GetCount ("B") - encoder_B_inicial
    encoder_C = Motor.GetCount ("C") - encoder_C_inicial
    
    error = encoder_B - encoder_C

    proporcional = error*2

    Motor.StartSync("BC", (Velocidad-proporcional), -(Velocidad+proporcional))

  EndWhile

  Motor.Stop("BC", "True")
  
  angulo_giro_final = theta - Math.GetDegrees(@thetatime)
  
  If angulo_giro_final > 0 Then
    V1 = Velocidad
    V2 = Velocidad * -1
  Else
    V1 = Velocidad * -1
    V2 = Velocidad
  EndIf
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = angulo_giro_final * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1/2, -V2/2, Encodr, "True")
  @xtcorrect = x
  @ytcorrect = y
  @thetatcorrect = math.getradians(theta)
  
EndFunction

Function GUnivEncMG(in number V1, in number V2, in number Angle)
  I = "B"
  D = "C"
  
  ' Constante que relaciona los grados de encoder necesarios para girar 1 grado en spin
  G1 = 110/36
  
  Signo = (V1 / V2) / Math.Abs(V1 / V2)
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = Angle * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1, -V2, Encodr, "True")
  
EndFunction

Function ToXY_Giro(in number Velocidad, in number x, in number y, in number theta)
EndFunction



Function BMoveA(in number degrees_per_second, in number degrees)
  
  #Para usar con control PID en paralelo
  
  rotation = degrees - @angle_A
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_A += degrees_per_interval
    progress += degrees_per_interval

    Program.Delay(1)
    
  EndWhile
  @angle_A = degrees
EndFunction

Function BMoveAPesado(in number degrees_per_second, in number degrees)
  
  #Para usar con control PID en paralelo
  
  old_kp_A = @kp_A
  old_ki_A = @ki_A
  old_kd_A = @kd_A
  
  @kp_A *= 15
  @ki_A *= 15
  @kd_A *= 15
  
  rotation = degrees - @angle_A
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_A += degrees_per_interval
    progress += degrees_per_interval

    Program.Delay(1)
    
  EndWhile
  @angle_A = degrees
  
  @kp_A = old_kp_A
  @ki_A = old_ki_A
  @kd_A = old_kd_A
EndFunction

Function BMoveD(in number degrees_per_second, in number degrees)
  
  #Para usar con control PID en paralelo
  
  rotation = degrees - @angle_D
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_D += degrees_per_interval
    progress += degrees_per_interval
    
    Program.Delay(1)
    
  EndWhile
  @angle_D = degrees
EndFunction

Function BMoveAD(in number degrees_per_second_A, in number degrees_per_second_D, in number degrees_A, in number degrees_D)
  
  #Para usar con control PID en paralelo
  
  While @angle_A <> degrees_A Or @angle_D <> degrees_D
    
    If Math.Round(@angle_A) < degrees_A - 5 and Math.Round(@angle_A) < degrees_A Then
      @angle_A += Math.Min(degrees_per_second_A, degrees_per_second_A/2 + (degrees_A - @angle_A) / 10)/50
    ElseIf Math.Round(@angle_A) > degrees_A + 5 and Math.Round(@angle_A) > degrees_A Then
      @angle_A -= Math.Max(degrees_per_second_A, degrees_per_second_A/2 + (degrees_A - @angle_A) / 10)/50
    Else
      @angle_A = degrees_A
    EndIf
    
    If Math.Round(@angle_D) < degrees_D Then
      @angle_D += Math.Min(degrees_per_second_D, degrees_per_second_D/2 + (degrees_D - @angle_D) / 10)/50
    ElseIf Math.Round(@angle_D) > degrees_D Then
      @angle_D -= Math.Max(degrees_per_second_D, degrees_per_second_D/2 + (degrees_D - @angle_D) / 10)/50
    Else
      @angle_D = degrees_D
    EndIf
    
    Program.Delay(1)
  EndWhile
  @angle_A = degrees_A  
  @angle_D = degrees_D
  
EndFunction

Function BMoveA0(in number degrees_per_second)
  
  #Para usar con control PID en paralelo
  
  degrees = 0
  rotation = degrees - @angle_A
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_A += degrees_per_interval
    progress += degrees_per_interval

    Program.Delay(1)
    
  EndWhile
  @angle_A = degrees
EndFunction

Function BMoveD0(in number degrees_per_second)
  
  #Para usar con control PID en paralelo
  
  degrees = 0
  rotation = degrees - @angle_D
  sign = Math.Abs(rotation)/rotation
  progress = 0
  
  degrees_per_interval = degrees_per_second * sign / 50
  
  While Math.Abs(rotation - progress) > 5
    
    @angle_D += degrees_per_interval
    progress += degrees_per_interval
    
    Program.Delay(1)
    
  EndWhile
  @angle_D = degrees
EndFunction

Function BMoveAD0(in number degrees_per_second_A, in number degrees_per_second_D)
  
  #Para usar con control PID en paralelo
  
  degrees_A = 0
  degrees_D = 0
  
  While @angle_A <> degrees_A Or @angle_D <> degrees_D
    
    If Math.Round(@angle_A) < degrees_A Then
      @angle_A += Math.Min(degrees_per_second_A, degrees_per_second_A/2 + (degrees_A - @angle_A) / 10)/50
    ElseIf Math.Round(@angle_A) > degrees_A Then
      @angle_A -= Math.Max(degrees_per_second_A, degrees_per_second_A/2 + (degrees_A - @angle_A) / 10)/50
    Else
      @angle_A = degrees_A
    EndIf
    
    If Math.Round(@angle_D) < degrees_D Then
      @angle_D += Math.Min(degrees_per_second_D, degrees_per_second_D/2 + (degrees_D - @angle_D) / 10)/50
    ElseIf Math.Round(@angle_D) > degrees_D Then
      @angle_D -= Math.Max(degrees_per_second_D, degrees_per_second_D/2 + (degrees_D - @angle_D) / 10)/50
    Else
      @angle_D = degrees_D
    EndIf
    
    Program.Delay(1)
  EndWhile
  @angle_A = degrees_A  
  @angle_D = degrees_D
  
EndFunction

