'Movimiento Recto con Motores Medianos


'Por encoder
Function Encoder(in number velocidad, in number distancia)
  
  enc = distancia*360 / Math.Pi / 6.24
  MotorBC.Off()
  Motor.MoveSync("BC",velocidad*-1,velocidad,enc,"True")

EndFunction

Function EncoderF(in number velocidad, in number distancia)

  enc = distancia*360 / Math.Pi / 6.24
  MotorBC.Off()
  Motor.MoveSync("BC",velocidad*-1,velocidad,enc,"False")

EndFunction

'Hasta negro en 1 Sensor
Function Negro1(in number velocidad, in number sensor)

  MotorBC.Off()
  While Sensor.ReadPercent(sensor) > 10

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.OffAndBrake()
EndFunction

Function Negro1F(in number velocidad, in number sensor)  
  
  MotorBC.Off()
  While Sensor.ReadPercent(sensor) > 10

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.Off()
EndFunction

'Hasta blanco en 1 Sensor
Function Blanco1(in number velocidad, in number sensor)  
  
  MotorBC.Off()
  While Sensor.ReadPercent(sensor) < 60

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.OffAndBrake()
EndFunction

Function Blanco1F(in number velocidad, in number sensor)  
  
  MotorBC.Off()
  While Sensor.ReadPercent(sensor) < 60

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.Off()
EndFunction

'Hasta negro en 2 Sensores
Function Negros2(in number velocidad, in number sensor1, in number sensor2)  

  MotorBC.Off()
  While Sensor.ReadPercent(sensor1) > 5 Or Sensor.ReadPercent(sensor2) > 5

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.OffAndBrake()
EndFunction

Function Negros2F(in number velocidad, in number sensor1, in number sensor2)  
  
  MotorBC.Off()
  While Sensor.ReadPercent(sensor1) > 5 Or Sensor.ReadPercent(sensor2) > 5

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.Off()
EndFunction

'Hasta blanco en 2 Sensores
Function Blancos2(in number velocidad, in number sensor1, in number sensor2)  
  
  MotorBC.Off()
  While Sensor.ReadPercent(sensor1) < 70 Or Sensor.ReadPercent(sensor2) < 70

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.OffAndBrake()
EndFunction

Function Blancos2F(in number velocidad, in number sensor1, in number sensor2)  
  
  MotorBC.Off()
  While Sensor.ReadPercent(sensor1) < 70 Or Sensor.ReadPercent(sensor2) < 70

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.Off()
EndFunction

'Hasta color en 1 Sensor
Function Color1(in number velocidad, in number sensor, in number color)  
  
  mode = Sensor.GetMode(sensor)
  Sensor.SetMode(sensor,2)
  
  MotorBC.Off()
  While Sensor.ReadRawValue(sensor,0) <> color

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.OffAndBrake()
  Sensor.SetMode(sensor,mode)
EndFunction

Function Color1F(in number velocidad, in number sensor, in number color)  
  
  mode = Sensor.GetMode(sensor)
  Sensor.SetMode(sensor,2)
  
  MotorBC.Off()
  While Sensor.ReadRawValue(sensor,0) <> color

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.Off()
  Sensor.SetMode(sensor,mode)
EndFunction

'Por tiempo
Function Tiempo(in number velocidad, in number tiempo)  

  Time.Reset3()
  
  MotorBC.Off()
  While Time.Get3() < tiempo

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.OffAndBrake()
EndFunction

Function TiempoF(in number velocidad, in number tiempo)  
  
  Time.Reset3()
  
  MotorBC.Off()
  While Time.Get3() < tiempo

    Motor.StartSync("BC", velocidad*-1, velocidad)

  EndWhile
  MotorBC.Off()
EndFunction

'Con Aceleración y deceleración
Function AccelDecel(in number v0, in number vMax, in number distancia1,in number distancia2, in number distancia3)
  
  Start_B = Motor.GetCount("B")
  Start_C = Motor.GetCount("C")
  
  encoderB = 0
  encoderC = 0
  
  v0 = Math.Max(8,v0)*1
  vMax = Math.Min(90,vMax)*1 'Limitamos las potencias
  
  vel = 0
  kp = 0.4
  ki = 0.0001
  kd = 0.5
  
  error = 0
  olderror = 0
  errsum = 0

  
  grados1 = distancia1*360/(5.6*math.pi)
  grados2 = distancia2*360/(5.6*math.pi)
  grados3 = distancia3*360/(5.6*math.pi)
  
  While encoderC < grados1 + grados2 + grados3
    
    encoderB = Motor.GetCount("B") - Start_B
    encoderC = Motor.GetCount("C") - Start_C
    
    #Acelera hasta la distancia de aceleración y se mantiene hasta la distancia de velocidad cte
    If encoderC < grados1 + grados2 Then
      ' Aceleración y velocidad Cte
      pendiente = (vMax - v0) / grados1
      vel = Math.Min(vMax, pendiente * encoderC + v0)
    Else
      ' Deceleración
      pendiente = (v0 - vMax) / grados3
      vel = Math.Max(v0, pendiente * (encoderC - grados1 - grados2) + vMax)
    EndIf
    
    #Correción PID para mantener el robot recto
    
    error = (-1*encoderB - encoderC)*1
    errsum += error
    correccion = error*kp + (error-olderror)*kd + errsum*ki 
    
    Motor.StartSync("BC",-(vel-correccion),(vel+correccion))
    olderror = error
  EndWhile
  
  MotorBC.OffAndBrake()
  
  LCD.Clear()
  LCD.Write(5,10,"distancia cm: " + MotorC.GetTacho() * 5.6 * Math.Pi /360)
EndFunction

Function AccelDecelF(in number v0, in number vMax, in number distancia1,in number distancia2, in number distancia3)
  
  Start_B = Motor.GetCount("B")
  Start_C = Motor.GetCount("C")
  
  encoderB = 0
  encoderC = 0
  
  v0 = Math.Max(8,v0)*1
  vMax = Math.Min(90,vMax)*1 'Limitamos las potencias
  
  vel = 0
  kp = 0.4
  ki = 0.0001
  kd = 0.5
  
  error = 0
  olderror = 0
  errsum = 0
  
  grados1 = distancia1*360/(5.6*math.pi)
  grados2 = distancia2*360/(5.6*math.pi)
  grados3 = distancia3*360/(5.6*math.pi)
  
  While encoderC < grados1 + grados2 + grados3
    
    encoderB = Motor.GetCount("B") - Start_B
    encoderC = Motor.GetCount("C") - Start_C
    
    #Acelera hasta la distancia de aceleración y se mantiene hasta la distancia de velocidad cte
    If encoderC < grados1 + grados2 Then
      ' Aceleración y velocidad Cte
      pendiente = (vMax - v0) / grados1
      vel = Math.Min(vMax, pendiente * encoderC + v0)
    Else
      ' Deceleración
      pendiente = (v0 - vMax) / grados3
      vel = Math.Max(v0, pendiente * (encoderC - grados1 - grados2) + vMax)
    EndIf
    
    #Correción PID para mantener el robot recto
    
    error = (-1*encoderB - encoderC)*1
    errsum += error
    correccion = error*kp + (error-olderror)*kd + errsum*ki 
    olderror = error
    Motor.StartSync("BC",-(vel-correccion),(vel+correccion))
    
  EndWhile
  
  MotorBC.Off()
  
  LCD.Clear()
  LCD.Write(5,10,"distancia cm: " + MotorC.GetTacho() * 5.6 * Math.Pi /360)
EndFunction


Function Decel(in number v0, in number vMin, in number distancia1,in number distancia2)
  
  v0 = Math.Min(90,v0)
  vMin = Math.Max(8,vMin) 'Limitamos las potencias
  
  vel = 0
  kp = 0.4
  ki = 0.0001
  kd = 0.5
  
  error = 0
  olderror = 0
  errsum = 0

  grados1 = distancia1*360/(5.6*math.pi)
  grados2 = distancia2*360/(5.6*math.pi)
  
  MotorB.ResetCount()
  MotorC.ResetCount()
  
  While MotorC.GetTacho() < grados1 + grados2
    
    #Acelera hasta la distancia de aceleración y se mantiene hasta la distancia de velocidad cte
    pendiente = (vMin - v0) / grados1
    vel = Math.Max(vMin, pendiente * MotorC.GetTacho() + v0)    
    #Correción PID para mantener el robot recto
    
    error = (-1*MotorB.GetTacho() - MotorC.GetTacho())*1
    errsum += error
    correccion = error*kp + (error-olderror)*kd + errsum*ki 
    olderror = error
    Motor.StartSync("BC",-(vel-correccion)*1,(vel+correccion)*1)
    
  EndWhile
  
  MotorBC.OffAndBrake()
  
  LCD.Clear()
  LCD.Write(5,10,"distancia cm: " + MotorC.GetTacho() * 5.6 * Math.Pi /360)
EndFunction

Function DecelF(in number v0, in number vMin, in number distancia1,in number distancia2)
  
  v0 = Math.Min(90,v0)
  vMin = Math.Max(8,vMin) 'Limitamos las potencias
  
  vel = 0
  kp = 0.4
  ki = 0.0001
  kd = 0.5
  
  error = 0
  olderror = 0
  errsum = 0
  
  grados1 = distancia1*360/(5.6*math.pi)
  grados2 = distancia2*360/(5.6*math.pi)
  
  MotorB.ResetCount()
  MotorC.ResetCount()
  
  While MotorC.GetTacho() < grados1 + grados2
    
    #Acelera hasta la distancia de aceleración y se mantiene hasta la distancia de velocidad cte
    pendiente = (vMin - v0) / grados1
    vel = Math.Max(vMin, pendiente * MotorC.GetTacho() + v0)    
    #Correción PID para mantener el robot recto
    
    error = (-1*MotorB.GetTacho() - MotorC.GetTacho())*1
    errsum += error
    correccion = error*kp + (error-olderror)*kd + errsum*ki 
    olderror = error
    Motor.StartSync("BC",-(vel-correccion)*1,(vel+correccion)*1)
    
  EndWhile
  
  MotorBC.Off()
  
  LCD.Clear()
  LCD.Write(5,10,"distancia cm: " + MotorC.GetTacho() * 5.6 * Math.Pi /360)
EndFunction
