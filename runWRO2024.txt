centro = 0
xtime = 0
ytime = 0
thetatime = 0
xtcorrect = 0
ytcorrect = 0
thetatcorrect = 0
Sentido_D = 1

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Velocidad = 100

kp = 0.2
ki = 0.0001
kd = 1

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dw = 102
Diameter = 56
D_T = 0

include "includes\Movimiento_Recto_MotMed"

include "includes\Giro_MotMed"
include "includes\GirosPerfectos_MotMed"
include "includes\GirosUniversales_MotMed"

include "includes\Aceleracion_MotMed"
include "includes\Deceleracion_MotMed"

include "includes\Siguelineas_MotMed"
include "includes\Siguelineas_MotMed_Smart"

include "includes\Brazo"

include "includes\RGBRead"

Setup()
Thread.Run = Odometry
Thread.Run = Display
Thread.Run = Stop
Main()

Sub Setup
  Sensor.SetMode(1,0)
  Sensor.SetMode(2,4)
  Sensor.SetMode(3,4)
  Sensor.SetMode(4,0)
EndSub

Sub StartArm
  
  Time.Reset1()
  While Time.Get1() < 850
    MotorA.StartSpeed(30)
    MotorD.StartSpeed(30)
  EndWhile
  
  MotorAD.OffAndBrake()
  
  MotorA.ResetCount()
  MotorD.ResetCount()
  
  BMoveD(40,-360)
  
  MotorD.ResetCount()
  
  Program.Delay(100)
EndSub

'Subs de control paralelo

Function Kalman_Filter(in number[] velI_k1, in number[] velD_k1)
  
  itreal = 0
  radio = 56/2
  
  MultiMatrizCoef(velI_k1,-1,velI)
  MultiMatrizCoef(velD_k1,-1,velD)
  
  'Paso de velocidad a rad/s
  
  MultiMatrizCoef(velI_k1,1/56.12,omegaI_k1) #56.12
  MultiMatrizCoef(velD_k1,1/59.88,omegaD_k1) #59.88
  
  I = Vector.Data(9,"1 0 0  0 1 0  0 0 1")
  minus_1 = Vector.Data(9,"-1 0 0 0 -1 0 0 0 -1")
  
  Q_k1 = Vector.Data(3*3, "0.25 0 0  0 0.25 0 0 0 0.002")
  
  delta_t = EV3.Time
  old_t = 0
  
  old_I = -1*MotorB.GetTacho()
  old_D = -1*MotorC.GetTacho()
  
  log_file = EV3File.OpenWrite("WRO2024/log.txt")
  
  While omegaI_k1[itreal] <> 0 Or omegaD_k1[itreal] <> 0
    
    df_k = Vector.Init(3*3,0)
    
    #Matriz de estimación de posición
    k_k1 = Vector.Init(3,0)
    
    #Matriz de posición ajustada
    k1_k = Vector.Init(3,0)
    
    H = Vector.Init(3,0)
    
    dH = Vector.Init(9,0)
    
    R = Vector.Data(9,"0.25 0 0  0 0.25 0 0 0 0.002")
    
    #Matriz de valores de los sensores
    z = Vector.Init(3,0)
    
    delta_t = EV3.Time - old_t
    old_t = EV3.Time
    
    @D_T = delta_t
    
    Motor.StartSync("BC",velI[itreal],velD[itreal])
    
    k_k1[0] = k_k1[0] + ((omegaI_k1[itreal]+omegaD_k1[itreal])*radio*delta_t)/2*Math.Cos(k_k1[2]+((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(4*@Dw))
    k_k1[1] = k_k1[1] + ((omegaI_k1[itreal]+omegaD_k1[itreal])*radio*delta_t)/2*Math.Sin(k_k1[2]+((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(4*@Dw))
    k_k1[2] = k_k1[2] + ((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(2*@Dw)
    
    df_k[2] = -1*((omegaI_k1[itreal]+omegaD_k1[itreal])*radio*delta_t)/2*Math.Sin(k_k1[2]+((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(4*@Dw))
    df_k[2] = ((omegaI_k1[itreal]+omegaD_k1[itreal])*radio*delta_t)/2*Math.Cos(k_k1[2]+((omegaD_k1[itreal]-omegaI_k1[itreal])*radio*delta_t)/(4*@Dw))
    
    F_k = Vector.Add(3*3,I,df_k)
    
    U = Vector.Multiply(3,3,3,F_k,I)
    TraspMatVect3x3(U,V)
    W = Vector.Multiply(3,3,3,U,V)
    P_k_k1 = Vector.Add(3*3,W,Q_k1)
    
    H[0] = (k_k1[2] - k1_k[2])*delta_t
    H[1] = (Math.SquareRoot(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2)) - @Dw*(k_k1[2]-k1_k[2])) / radio
    H[2] = (Math.SquareRoot(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2)) + @Dw*(k_k1[2]-k1_k[2])) / radio
    
    dH[2] = 1/delta_t
    dH[3] = Math.Power(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2),-1/2)*(k_k1[0]-k1_k[0])/radio
    dH[4] = Math.Power(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2),-1/2)*(k_k1[1]-k1_k[1])/radio
    dH[5] = -@Dw/radio
    dH[6] = Math.Power(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2),-1/2)*(k_k1[0]-k1_k[0])/radio
    dH[7] = Math.Power(Math.Power(k_k1[0]-k1_k[0],2)+Math.Power(k_k1[1]-k1_k[1],2),-1/2)*(k_k1[1]-k1_k[1])/radio
    dH[8] = @Dw/radio
    
    z[0] = Sensor.ReadRawValue(2,0)
    z[1] = -1*MotorB.GetTacho() - old_I
    z[2] = -1*MotorC.GetTacho() - old_D
    
    minus_H = Vector.Multiply(1,3,3,H,minus_1)
    
    y = Vector.Add(3,z,minus_H)
    
    #Matriz S de covarianza residual
    S1 = Vector.Multiply(3,3,3,dH,P_k_k1)
    TraspMatVect3x3(dH,dH_T)
    S2 = Vector.Multiply(3,3,3,S1,dH_T)
    S = Vector.Add(9,S2,R)
    
    #Matriz K de ganancia de kalman
    K1 = Vector.Multiply(3,3,3,P_k_k1,dH_T)
    InvMatVect3x3(S,S_inv)
    K = Vector.Multiply(3,3,3,K1,S_inv)
    
    Ky = Vector.Multiply(3,3,3,K,y)
    
    k1_k = Vector.Add(9,k_k1,Ky)
    
    KH = Vector.Multiply(3,3,3,K,dH_T)
    minus_KH = Vector.Multiply(3,3,3,KH,minus_1)
    P1 = Vector.Multiply(3,3,3,I,minus_KH)
    
    #Matriz de covarianza actualizada
    P = Vector.Multiply(3,3,3,P1,P_k_k1)
    
    EV3File.WriteLine(log_file,"Medidas de entrada Izq: "+omegaI_k1[itreal])
    
    EV3File.WriteLine(log_file,"Medidas de entrada Dch: "+omegaD_k1[itreal])
    
    EV3File.WriteLine(log_file,"Sensor color: "+z[0])
    EV3File.WriteLine(log_file,"Encoder I: "+MotorB.GetTacho()*-1)
    EV3File.WriteLine(log_file,"Encoder D: "+MotorC.GetTacho()*-1)
    
    'For j = 0 To 8
      'EV3File.WriteLine(log_file,"Valor["+j+"] de P: "+P[j])
    'EndFor
    
    EV3File.WriteLine(log_file,"Iteración: "+itreal)
    EV3File.WriteLine(log_file,"Delta t: "+delta_t+" ms")
    
    EV3File.WriteLine(log_file,"---------------")
    EV3File.WriteLine(log_file,"")

    itreal ++
    
    old_I = -1*MotorB.GetTacho()
    old_D = -1*MotorC.GetTacho()
  EndWhile
  
EndFunction

Sub Odometry
  
  alpha_L[0] = 0
  alpha_R[0] = 0
  
  oldB = 0
  oldC = 0

  xt[0] = 0
  yt[0] = 0
  thetat[0] = 0

  i = 0
  While "True"

    alpha_L[i] = Math.GetRadians(MotorB.GetTacho()*-1)
    alpha_R[i] = Math.GetRadians(MotorC.GetTacho())
    
    
    d_L = (alpha_L[i]-alpha_L[i-1]) * Diameter/2
    d_R = (alpha_R[i]-alpha_R[i-1]) * Diameter/2

    d = (d_L + d_R) / 2

    delta_theta = (d_R - d_L) / (2 * Dw)

    xt[i+1] = (d * Math.Sin(thetat[i] + delta_theta / 2) + xt[i])
    
    yt[i+1] = (d * Math.Cos(thetat[i] + delta_theta / 2) + yt[i])
   
    thetat[i+1] = thetat[i] + delta_theta
    
    xtime = xt[i+1]
    ytime = yt[i+1]
    thetatime = thetat[i+1]
    
    i++

    Program.Delay(10)
    
  EndWhile
EndSub

Sub Display
  old_B = 0
  old_C = 0
  While "True"
    LCD.StopUpdate()
    LCD.Clear()
    
    LCD.Write(5,5,"xt: "+Math.Round(xt[i]*100)/100)
    LCD.Write(5,15,"yt: "+Math.Round(yt[i]*100)/100)
    LCD.Write(5,25,"thetat: "+math.getdegrees(thetat[i]))
    
    
    LCD.Write(5,35,"centro: "+centro)
    
    
    LCD.Write(5,45,"Velocidad de B:  "+MotorB.GetSpeed()*-1)
    LCD.Write(5,55,"Velocidad de C:  "+MotorC.GetSpeed())
    
    LCD.Write(5,65,"rad/s de B:  "+Math.GetRadians(MotorB.GetTacho()-old_B)/0.05*-1)
    LCD.Write(5,75,"rad/s de C:  "+Math.GetRadians(MotorC.GetTacho()-old_C)/0.05)
    
    LCD.Write(5,85,"Encoder de B:  "+MotorB.GetTacho()*-1)
    LCD.Write(5,95,"Encoder de C:  "+MotorC.GetTacho())
    
    LCD.Write(5,105,"Delta T:  "+D_T)
    
    
    'LCD.Write(5,75,"Angulo de A:  "+MotorA.GetTacho())
    'LCD.Write(5,85,"Obj de A:  "+angle_A)
    
    'LCD.Write(5,95,"Angulo de D:  "+MotorD.GetTacho())
    'LCD.Write(5,105,"Obj de D:  "+angle_D)
    
    'LCD.Write(5,115,"Sentido de D:  "+Sentido_D)
    LCD.Update()
    Program.Delay(50)
    old_B = MotorB.GetTacho()
    old_C = MotorC.GetTacho()
  EndWhile
EndSub

Sub DisplayVelocidades
  old_B = 0
  old_C = 0
  agg_B = 0
  agg_C = 0
  iteracion = 0
  While "True"
    iteracion++
    LCD.StopUpdate()
    LCD.Clear()
    
    LCD.Write(5,45,"Velocidad de B:  "+MotorB.GetSpeed()*-1)
    LCD.Write(5,55,"Velocidad de C:  "+MotorC.GetSpeed()*-1)
    
    rads_B = Math.GetRadians(MotorB.GetTacho()-old_B)/0.05*-1
    rads_C = Math.GetRadians(MotorC.GetTacho()-old_C)/0.05*-1
    
    agg_B += rads_B
    agg_C += rads_C
    
    media_B = agg_B/iteracion
    media_C = agg_C/iteracion
    
    LCD.Write(5,65,"rad/s de B: "+media_B)
    LCD.Write(5,75,"rad/s de C: "+media_C)
    
    LCD.Update()
    Program.Delay(50)
    old_B = MotorB.GetTacho()
    old_C = MotorC.GetTacho()
  EndWhile
EndSub

'Subs a ejecutar

Sub Main
  
  StartArm()
  
  EncoderRectoMM(Velocidad*0.3,35)
  GUnivEncMM(Velocidad*0.2,Velocidad*-0.2,81)
  BMoveA(20,-100) 'Esto con el caso de arriba no se necesitaba
  
  EncoderRectoMMF(Velocidad*0.3,10)
  
  RGBDetect1(5,caso)
  LeerColor(caso)
  Sensor.SetMode(1,0)
  If caso = 3 Then
    Caso_Verde()
  Else
    Caso_Rojo()
  EndIf
  
  
EndSub

Sub MainPrueba
  
  rojos = 0
  amarillos = 0
  verdes = 0
  azules = 0
  
  StartArm()
  
  Motor.Move("BC",30,1173/4,"True")
EndSub

Sub MainControlBrazo
  angle_A = 0
  angle_D = 0  
  
  While "True"
    If Buttons.Current = "U" Then
      angle_A -= 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "D" Then
      angle_A += 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "L" Then
      angle_D -= 1
      Program.Delay(1)
    ElseIf Buttons.Current = "R" Then
      angle_D += 1
      Program.Delay(1)
    EndIf
  EndWhile
EndSub

Sub MainControlRuedas
  vel_B = 92
  vel_C = 92
  
  While "True"
    If Buttons.Current = "U" Then
      vel_B -= 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "D" Then
      vel_B += 0.5
      Program.Delay(1)
    ElseIf Buttons.Current = "L" Then
      vel_C += 1
      Program.Delay(1)
    ElseIf Buttons.Current = "R" Then
      vel_C -= 1
      Program.Delay(1)
    EndIf
    Motor.StartSync("BC",-vel_B,-vel_C)
  EndWhile
EndSub


Sub Caso_Verde
  
  rojos = 0
  amarillos = 0
  verdes = 0
  azules = 0
  
  'Gira hacia tubería
  GUnivEncMM(Velocidad*0.2,Velocidad*-0.2,170)
  Program.Delay(500)
  
  'Avanza a tubería
  EncoderRectoMM(Velocidad*-0.3,2)
  
  EncoderGiroMM(Velocidad*0.3,Velocidad*0.425,34)
  EncoderGiroMM(Velocidad*0.375,Velocidad*0.3,31.5)
  Program.Delay(500)
  
  'Lee línea
  1NegroRectoMM(Velocidad*0.12,4)
  EncoderRectoMM(Velocidad*-0.3,15)
  
  'Cierra y Baja brazo
  BMoveD(20,-300)
  BMoveA(20,-780)
  
  'Recoloca
  GUnivEncMM(Velocidad*-0.1,Velocidad*0.1,16)
  Program.Delay(1000)
  EncoderRectoMM(Velocidad*0.12,6)
  
  'Sube Brazo y gira
  BMoveA(20,-580)
  Program.Delay(1000)
  Spin90(10)
  Spin90(-10)
  
  'Echa hacia atrás
  EncoderRectoMM(Velocidad*-0.3,24)
  BMoveAD0(40)
  
  'Gira para colocar con pared (x2)
  GUnivEncMM(Velocidad*0.2,Velocidad*-0.2,100)
  
  TiempoRectoMM(Velocidad*-0.8,2000)
  EncoderRectoMM(Velocidad*0.3,3.5)
  
  TiempoRectoMM(Velocidad*-0.8,500)
  EncoderRectoMM(Velocidad*0.3,3.5)
  
  'Gira hacia bloques azules/verdes y avanza
  GUnivEncMM(Velocidad*-0.3,Velocidad*0.3,93)
  EncoderRectoMM(Velocidad*0.3,31)
  Program.Delay(1000)
  
  Lectura(bloque)
  If bloque <> 3 And bloque <> 2 Then
    'Si no hay bloque
    numero_bloques = 0
    bomboclat[0] = 0
  Else
    bomboclat[0] = bloque
    numero_bloques = 1
    
    If bloque = 3 Then
      verdes ++
    Else
      azules ++
    EndIf
    
    Coger_Abajo()
    
  EndIf
  
  'Gira al segundo
  
  EncoderRectoMM(Velocidad*-0.2,5)
  GUnivEncMM(Velocidad*0.2,Velocidad*-0.2,92)
  
  EncoderRectoMM(Velocidad*0.2,9.5)
  Spin90(-20)
  
  EncoderRectoMM(Velocidad*0.2,14)
  Lectura(bloque)
  
  If bloque <> 3 and bloque <> 2 Then
    bomboclat[1] = bomboclat[0]
    
    bomboclat[0] = 0
  Else
    bomboclat[1] = bloque
    numero_bloques ++
    
    If numero_bloques = 1 Then
      
      'Si no lleva bloque
      Coger_Abajo()
      
    Else
      
      'Si lleva Bloque
      Coger_Arriba()
      
    EndIf
    
  EndIf
  
  'Gira hacia linea
  GUnivEncMM(Velocidad*0.3,Velocidad*-0.3,170)
  EncoderRectoMM(Velocidad*0.5,57)
  GUnivEncMM(Velocidad*-0.2, Velocidad*0.2,90)
  
  'Lee línea
  1BlancoRectoMM(Velocidad*0.3,1)
  1NegroRectoMM(Velocidad*0.2,1)
  
  'Gira a derecha y avanza hasta cruce
  GPerfDDEFINITIVOMM(Velocidad*0.2)
  SL14PIDEnc(Velocidad*0.3,kp,ki,kd,10)
  
  If numero_bloques > 0 Then
    
    'Avanza hacia las zonas verde y azul
    GUnivEncMM(Velocidad*-0.3,Velocidad*0.3,86)
    EncoderRectoMM(Velocidad*0.3,12)
    
    if numero_bloques = 1 Then
      
      'Si solo tiene un bloque
      if bomboclat[0] = 2 Then
        
        'Es azul
        GUnivEncMM(Velocidad*0.3,Velocidad*0.1,40)
        Soltar_Todo()
        GUnivEncMM(Velocidad*-0.3,Velocidad*-0.1,40)
      Else
        
        'Es verde
        GUnivEncMM(Velocidad*0.1,Velocidad*0.3,40)
        Soltar_Todo()
        GUnivEncMM(Velocidad*-0.1,Velocidad*-0.3,40)
      EndIf
      
      
    Else
      
      'Si tiene 2 bloques
      
      If bomboclat[0] = bomboclat[1] Then
        
        
        If bomboclat[0] = 2 Then
          GUnivEncMM(Velocidad*0.3,Velocidad*0.1,40)
          Soltar_Todo()
          GUnivEncMM(Velocidad*-0.3,Velocidad*-0.1,40)
        Else
          GUnivEncMM(Velocidad*0.1,Velocidad*0.3,40)
          Soltar_Todo()
          GUnivEncMM(Velocidad*-0.1,Velocidad*-0.3,40)
        EndIf
        
        
      Else
        
        If bomboclat[0] = 2 Then
          
          GUnivEncMM(Velocidad*0.3,Velocidad*0.1,40)
          Soltar_Uno()
          GUnivEncMM(Velocidad*-0.3,Velocidad*-0.1,40)
          
          GUnivEncMM(Velocidad*0.1,Velocidad*0.3,40)
          Soltar_Todo()
          GUnivEncMM(Velocidad*-0.1,Velocidad*-0.3,40)
          
        Else
          
          GUnivEncMM(Velocidad*0.1,Velocidad*0.3,40)
          Soltar_Uno()
          GUnivEncMM(Velocidad*-0.1,Velocidad*-0.3,40)
          
          GUnivEncMM(Velocidad*0.3,Velocidad*0.1,40)
          Soltar_Todo()
          GUnivEncMM(Velocidad*-0.3,Velocidad*-0.1,40)
          
        EndIf
        
        
      EndIf
      
    EndIf
    
    BMoveAD0(20)
    1BlancoRectoMM(Velocidad*-0.3,1)
    1NegroRectoMM(Velocidad*-0.3,1)
    
    GPerfDDEFINITIVOMM(Velocidad*0.3)
    SL14PIDEnc(Velocidad*0.3,kp,ki,kd,5)
    SL1SPIDCrossF(Velocidad*0.3,kp,ki,kd,1,1)
    
  Else
    
    SL1SPIDCrossF(Velocidad*0.3,kp,ki,kd,1,1)
  EndIf
  

EndSub

Sub Caso_Rojo
  
  GUnivEncMM(Velocidad*0.14,Velocidad*-0.14,168)
  Program.Delay(1000)
  EncoderRectoMM(Velocidad*-0.2,2)
  EncoderGiroMM(Velocidad*0.3,Velocidad*0.53,36.5)
  Program.Delay(1000)
  EncoderGiroMM(Velocidad*0.5,Velocidad*0.3,34)
  Program.Delay(1000)
  
  1NegroRectoMM(Velocidad*0.12,1)
  EncoderRectoMM(Velocidad*-0.3,15)
  BMoveD(20,-300)
  BMoveA(20,-780)
  GUnivEncMM(Velocidad*-0.2,Velocidad*0.2,16)
  EncoderRectoMM(Velocidad*0.12,6)
  BMoveA(20,-580)
  Program.Delay(1000)
  Spin90(10)
  Spin90(-10)
  BMoveAD0(30)
  EncoderRectoMM(Velocidad*-0.3, 30)
  BMoveAD0(30)
  GUnivEncMM(Velocidad*0.3,Velocidad*-0.3,135)
  Program.Delay(1000)
  EncoderRectoMM(Velocidad*0.6, 30)
  1BlancoRectoMMF(Velocidad*0.3,1)
  1NegroRectoMMF(Velocidad*0.2,1)
  EncoderRectoMM(Velocidad*0.3,2)
  GUnivEncMM(Velocidad*0.3,Velocidad*-0.2,35)
  SL14PIDEnc(Velocidad*0.25,kp*1.25,ki,kd,10)
  SL1SPIDCross(Velocidad*0.3,kp,ki,kd,4,1)
  SL14PIDEnc(Velocidad*0.7,kp,ki,kd,36)
  EncoderGiroMM(Velocidad*0.3,Velocidad*0.2,23)
  EncoderGiroMM(Velocidad*0.2,Velocidad*0.3,25)
  EncoderRectoMM(Velocidad*0.2,25)
  
  
  Coger_Abajo_Basura()
  BMoveA(20, -780)
  GUnivEncMM(Velocidad*0.2, Velocidad*-0.2, 10)
  Program.Delay(1000)
  EncoderRectoMM(Velocidad*0.2, 6)
  BMoveA(20,-580)
  Program.Delay(1000)
  GUnivEncMM(Velocidad*0.1,0,50)
  GUnivEncMM(Velocidad*-0.1,0,50)
  BMoveA0(30)
  
  GUnivEncMM(Velocidad*0.3,Velocidad*-0.3,146)
  sinAccelDecelMM(Velocidad*0.2,Velocidad*0.8,200)
  BMoveA(20,-780)
  BMoveD0(20)
  
EndSub

Sub Stop
  While "True"
    if Buttons.Current = "E" Then
      MotorBC.OffAndBrake()
      MotorAD.OffAndBrake()
      BMoveADSafe(20,0)
      Program.End()
    EndIf
  EndWhile
EndSub


Function Coger_Abajo()
  
  EncoderRectoMM(-30,5)
  
  'Coge el primero
  
  BMoveD(40,-220)
  BMoveA(20,-780)
  BMoveDTimer(-40,350)
  BMoveA(20,-300)
  
EndFunction

Function Coger_Abajo_Basura()
  
  EncoderRectoMM(-30,2)
  
  'Coge el primero
  
  BMoveD(40,-130)
  BMoveA(20,-780)
  BMoveDTimer(-40,500)
  BMoveA(20,-300)
  
EndFunction

Function Coger_Arriba()
  
  EncoderRectoMM(-20,6.5)
  
  BMoveA(10,-670)
  BMoveD(20,-200)
  
  'Coge el segundo
  
  'EncoderRectoMM(10,0.75)
  BMoveA(10,-780)
  
  BMoveDSafe(40,-250)
  BMoveDTimer(-40,400)
  BMoveA(20,-400)
  
  
  
EndFunction

Function Soltar_Todo()
  
  EncoderRectoMM(-30,5)
  
  BMoveA(10,-750)
  BMoveDSafe(40,-200)
  
  BMoveA(10,-500)
  
EndFunction

Function Soltar_Uno()
  
  EncoderRectoMM(-30,5)
  
  BMoveA(10,-760)
  BMoveDSafe(40,-200)
  
  BMoveA(10,-660)
  BMoveDSafe(40,-250)
  BMoveDTimer(-40,200)
  
  BMoveA(10,-500)
  
EndFunction


Function ToXY_Basic(in number Velocidad, in number x, in number y, in number theta)
  
  I = "B"
  D = "C"
  
  ' Constante que relaciona los grados de encoder necesarios para girar 1 grado en spin
  G1 = 110/36
  
  Signo = -1
  
  diff_x = x - @xtime
  diff_y = y - @ytime
  
  angulo_giro_inicial = Math.getDegrees(Math.ArcTan((x-@xtime)/(y-@ytime)))
  
  @angulo = angulo_giro_inicial
  If diff_y < 0 Then
    If diff_x < 0 Then
			angulo_giro_inicial = angulo_giro_inicial - 180 - @thetatime
		ElseIf diff_x > 0 Then
			angulo_giro_inicial = 0 - @thetatime - angulo_giro_inicial
    EndIf
  EndIf
  
  If angulo_giro_inicial > 0 Then
    V1 = Velocidad
    V2 = Velocidad * -1
  Else
    V1 = Velocidad * -1
    V2 = Velocidad
  EndIf
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = angulo_giro_inicial * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1/2, -V2/2, Encodr, "True")
  
  distancia =  Math.SquareRoot(diff_x*diff_x + diff_y*diff_y)

  Enc = distancia*360 / Math.Pi / @Diameter
  
  encoder_B_inicial = Motor.GetCount ("B")
  encoder_C_inicial = Motor.GetCount ("C")

  While Math.abs(Motor.GetCount ("C") - encoder_C_inicial) < Enc
    
    encoder_B = Motor.GetCount ("B") - encoder_B_inicial
    encoder_C = Motor.GetCount ("C") - encoder_C_inicial
    
    error = encoder_B - encoder_C

    proporcional = error*2

    Motor.StartSync("BC", (Velocidad-proporcional), -(Velocidad+proporcional))

  EndWhile

  Motor.Stop("BC", "True")
  
  angulo_giro_final = theta - Math.GetDegrees(@thetatime)
  
  If angulo_giro_final > 0 Then
    V1 = Velocidad
    V2 = Velocidad * -1
  Else
    V1 = Velocidad * -1
    V2 = Velocidad
  EndIf
  
  Vmin = Math.Min(Math.Abs(V1), Math.Abs(V2))
  Vmax = Math.Max(Math.Abs(V1), Math.Abs(V2))
  
  @centro = (-8.5*(Vmin/Vmax)*Signo-8.5)/((Vmin/Vmax)*Signo-1)
  Encodr = angulo_giro_final * G1 * (-2 / (Signo * Vmin / Vmax - 1))
  
  Motor.MoveSync(I + D, -V1/2, -V2/2, Encodr, "True")
  @xtcorrect = x
  @ytcorrect = y
  @thetatcorrect = math.getradians(theta)
  
EndFunction

Function ToXY_Giro(in number Velocidad, in number x, in number y, in number theta)
EndFunction


Function Lectura(out number read)
  BmoveA(15,-650)
  RGBDetect2(5,read)
  LeerColor(read)
  BmoveA(15,-200)
EndFunction


Function TraspMatVect3x3(in number[] M, out number[] S)
  
  S = Vector.Init(3*3,0)
  
  S[0] = M[0] 
  S[1] = M[3] 
  S[2] = M[6] 
  
  S[3] = M[1] 
  S[4] = M[4] 
  S[5] = M[7] 
  
  S[6] = M[2] 
  S[7] = M[5] 
  S[8] = M[8] 
  
EndFunction

Function InvMatVect3x3(in number[] M, out number[] S)
  
  'Hallamos determinante
  
  Determinante = M[0]*(M[4]*M[8]-M[5]*M[7]) - M[1]*(M[3]*M[8]-M[5]*M[6]) + M[2]*(M[3]*M[7]-M[4]*M[6])
  If Determinante <> 0 Then
    
    S[0] = (M[4]*M[8]-M[5]*M[7]) / Determinante
    S[1] = (M[3]*M[8]-M[5]*M[6]) / Determinante
    S[2] = (M[3]*M[7]-M[4]*M[6]) / Determinante
    
    S[3] = (M[1]*M[8]-M[2]*M[7]) / Determinante
    S[4] = (M[0]*M[8]-M[2]*M[6]) / Determinante
    S[5] = (M[0]*M[7]-M[1]*M[6]) / Determinante
    
    S[6] = (M[1]*M[5]-M[2]*M[4]) / Determinante
    S[7] = (M[0]*M[5]-M[2]*M[3]) / Determinante
    S[8] = (M[0]*M[4]-M[1]*M[3]) / Determinante
    
  EndIf
  
EndFunction

Function MultiMatrizCoef(in number[] M, in number k, out number[] S)
  
  i = 0
  
  While M[i] <> 0
    
    S[i] = k * M[i]
    
    i++
  EndWhile
  
EndFunction